<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Chester.Cao Blog</title>
  
  <subtitle>Devlopper in C#</subtitle>
  <link href="http://blog.rcant.com/atom.xml" rel="self"/>
  
  <link href="http://blog.rcant.com/"/>
  <updated>2023-01-06T09:36:27.732Z</updated>
  <id>http://blog.rcant.com/</id>
  
  <author>
    <name>Chester.C</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>从程序员到架构师 学习</title>
    <link href="http://blog.rcant.com/2021/03/09/framework/programmer-grow-0/"/>
    <id>http://blog.rcant.com/2021/03/09/framework/programmer-grow-0/</id>
    <published>2021-03-09T03:39:17.000Z</published>
    <updated>2023-01-06T09:36:27.732Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>架构风格</p><p>人才，以及合理的人才结构，是软件公司乃至软件业发展的关键<br>成才，并在企业中承担重要职责，是个人职业发展的关键</p><h2 id="从程序员到架构师转型"><a href="#从程序员到架构师转型" class="headerlink" title="从程序员到架构师转型"></a>从程序员到架构师转型</h2><p>一个软企发展的好坏，极大的取决于如下人才因素：</p><ul><li>员工素质</li><li>人才结构</li><li>员工职业技能的纵深积累</li><li>员工职业技能的适时更新</li></ul><p>要让软件企业适应发展，需要：</p><ul><li>定期分析和掌握本公司员工能力状况、人才结构状况</li><li>员工专项技能的渐进提升（如架构技能，设计重构技能）</li><li>研发骨干整体技能的跨越转型（例如 高级工程师向架构师，系统工程师和技术经理的转型）</li></ul><p>提升个人技能，也是让企业获取人才的合适途径</p><span id="more"></span><h2 id="本书价值"><a href="#本书价值" class="headerlink" title="本书价值"></a>本书价值</h2><p>第一部分 基础概念<br>第二部分 实践过程<br>第三部分 模块划分</p><h3 id="入门"><a href="#入门" class="headerlink" title="入门"></a>入门</h3><p>需要阅读 基础概念篇 + 模块划分专题</p><ul><li>基础概念篇：讲解如何运用 逻辑视图+物理视图 设计架构</li><li>模块划分篇：讲解模块划分的不同方法，讨论功能模块、分层架构、用例驱动的模块划分过程等内容</li></ul><p>需要 体会 “分而治之” 和 “迭代式设计” 这两种关键思想，运用 “逻辑视图+物理视图” 设计一个系统的架构也就不那么难了</p><p>用 逻辑视图和物理视图 是从解决问题的不同角度看，从而关注一个解决问题的不同细节。相当于化大问题为小问题。</p><p>逻辑视图和物理视图 交替迭代式展开。逻辑视图逐步清晰，促进物理分布设计。反之亦然。</p><p>模块划分的四种方式</p><ul><li>水平分层</li><li>垂直划分功能模块</li><li>从用例到类、再到模块</li><li>想到哪 切到哪</li></ul><h3 id="软件架构概念"><a href="#软件架构概念" class="headerlink" title="软件架构概念"></a>软件架构概念</h3><h4 id="组成派"><a href="#组成派" class="headerlink" title="组成派"></a>组成派</h4><p>软件架构关注分割和交互</p><p>可以将系统描述为计算机组件和组件之间的交互</p><h4 id="决策派"><a href="#决策派" class="headerlink" title="决策派"></a>决策派</h4><p>软件架构师一系列有层次的决策</p><p>架构属于设计，但并非所有设计都属于架构。<br>架构涉及的决策，往往对整体质量、并行开发、适应变化等方面有着重大影响</p><ul><li>模块如何划分</li><li>每个模块的职责为何</li><li>每个模块的接口如何定义</li><li>模块间采用何种交互机制</li><li>开发技术如何选型</li><li>如何满足约束和质量属性的需求</li><li>如何适应可能发生的变化</li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;架构风格&lt;/p&gt;
&lt;p&gt;人才，以及合理的人才结构，是软件公司乃至软件业发展的关键&lt;br&gt;成才，并在企业中承担重要职责，是个人职业发展的关键&lt;/p&gt;
&lt;h2 id=&quot;从程序员到架构师转型&quot;&gt;&lt;a href=&quot;#从程序员到架构师转型&quot; class=&quot;headerlink&quot; title=&quot;从程序员到架构师转型&quot;&gt;&lt;/a&gt;从程序员到架构师转型&lt;/h2&gt;&lt;p&gt;一个软企发展的好坏，极大的取决于如下人才因素：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;员工素质&lt;/li&gt;
&lt;li&gt;人才结构&lt;/li&gt;
&lt;li&gt;员工职业技能的纵深积累&lt;/li&gt;
&lt;li&gt;员工职业技能的适时更新&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要让软件企业适应发展，需要：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;定期分析和掌握本公司员工能力状况、人才结构状况&lt;/li&gt;
&lt;li&gt;员工专项技能的渐进提升（如架构技能，设计重构技能）&lt;/li&gt;
&lt;li&gt;研发骨干整体技能的跨越转型（例如 高级工程师向架构师，系统工程师和技术经理的转型）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;提升个人技能，也是让企业获取人才的合适途径&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://blog.rcant.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://blog.rcant.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>学习Autoconf</title>
    <link href="http://blog.rcant.com/2020/11/13/cpp/cpp-autoconf-0/"/>
    <id>http://blog.rcant.com/2020/11/13/cpp/cpp-autoconf-0/</id>
    <published>2020-11-13T03:39:17.000Z</published>
    <updated>2021-12-15T07:06:27.478Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile其实不难学，对于一些基本概念百度上应该很多，这里分享一个循序渐进的学习方式，保证让你快速掌握Makefile的编写。本文首发于公众号：良许Linux，里面有一个 Makefile 系列，欢迎关注交流！</p><span id="more"></span>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile其实不难学，对于一些基本概念百度上应该很多，这里分享一个循序渐进的学习方式，保证让你快速掌握Makefile的编写。本文首发于公众号：良许Linux，里面有一个 Makefile 系列，欢迎关注交流！&lt;/p&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习CMake</title>
    <link href="http://blog.rcant.com/2020/11/13/cpp/cpp-cmake-0/"/>
    <id>http://blog.rcant.com/2020/11/13/cpp/cpp-cmake-0/</id>
    <published>2020-11-13T03:39:17.000Z</published>
    <updated>2023-01-06T09:29:02.856Z</updated>
    
    <content type="html"><![CDATA[<p>你或许听过好几种 Make 工具，例如 <a href="https://www.hahack.com/wiki/tools-makefile.html">GNU Make</a> ，QT 的 <a href="http://qt-project.org/doc/qt-4.8/qmake-manual.html">qmake</a> ，微软的 <a href="http://msdn.microsoft.com/en-us/library/ms930369.aspx">MS nmake</a>，BSD Make（<a href="http://www.freebsd.org/doc/en/books/pmake/">pmake</a>），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。</p><p>CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 [1]。</p><p>在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：</p><ol><li>编写 CMake 配置文件 CMakeLists.txt 。</li><li>执行命令 <span class="label warning">cmake PATH</span> 或者 <span class="label warning">ccmake PATH</span> 生成 Makefile ( <span class="label warning">ccmake</span> 和 <span class="label warning">cmake</span> 的区别在于前者提供了一个交互式的界面)。其中， <span class="label warning">PATH</span> 是 CMakeLists.txt 所在的目录。</li><li>使用 <span class="label warning">make</span> 命令进行编译。</li></ol><p>本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在这里找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。</p><span id="more"></span><h2 id="入门案例-单个源文件"><a href="#入门案例-单个源文件" class="headerlink" title="入门案例: 单个源文件"></a>入门案例: 单个源文件</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo1.zip" title="源码下载">Demo1</a>。</p>          </div><p>假设项目中只有一个文件 main.cc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">* power - Calculate the power of number.</span><br><span class="line">* @param base: Base value.</span><br><span class="line">* @param exponent: Exponent value.</span><br><span class="line">*</span><br><span class="line">* @return base raised to the power exponent.</span><br><span class="line">*/</span><br><span class="line">double power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    int result = base;</span><br><span class="line">    int i;</span><br><span class="line">    if (exponent == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 1; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-CMakeLists-txt"><a href="#编写-CMakeLists-txt" class="headerlink" title="编写 CMakeLists.txt"></a>编写 CMakeLists.txt</h3><p>首先编写 CMakeLists.txt 文件，并保存在与 main.cc 源文件同个目录下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo1)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc)</span><br></pre></td></tr></table></figure><p>CMakeLists.txt 的语法比较简单，由命令、注释和空格组成，其中命令是不区分大小写的。符号 <span class="label danger">#</span> 后面的内容被认为是注释。命令由命令名称、小括号和参数组成，参数之间使用空格进行间隔。</p><p>对于上面的 CMakeLists.txt 文件，依次出现了几个命令：</p><ol><li><span class="label danger">cmake_minimum_required</span> ：指定运行此配置文件所需的 CMake 的最低版本；</li><li><span class="label danger">project</span> ：参数值是 Demo1，该命令表示项目的名称是 Demo1 。</li><li><span class="label danger">add_executable</span>： 将名为 main.cc 的源文件编译成一个名称为 Demo 的可执行文件。</li></ol><h3 id="编译项目"><a href="#编译项目" class="headerlink" title="编译项目"></a>编译项目</h3><p>之后，在当前目录执行 <span class="label danger">cmake .</span> ，得到 Makefile 后再使用 <span class="label danger">make</span> 命令编译得到 Demo1 可执行文件。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">[ehome@xman Demo1]$ cmake .</span><br><span class="line">-- The C compiler identification is GNU 4.8.2</span><br><span class="line">-- The CXX compiler identification is GNU 4.8.2</span><br><span class="line">-- Check for working C compiler: /usr/sbin/cc</span><br><span class="line">-- Check for working C compiler: /usr/sbin/cc -- works</span><br><span class="line">-- Detecting C compiler ABI info</span><br><span class="line">-- Detecting C compiler ABI info - done</span><br><span class="line">-- Check for working CXX compiler: /usr/sbin/c++</span><br><span class="line">-- Check for working CXX compiler: /usr/sbin/c++ -- works</span><br><span class="line">-- Detecting CXX compiler ABI info</span><br><span class="line">-- Detecting CXX compiler ABI info - done</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /home/ehome/Documents/programming/C/power/Demo1</span><br><span class="line">[ehome@xman Demo1]$ make</span><br><span class="line">Scanning dependencies of target Demo</span><br><span class="line">[100%] Building C object CMakeFiles/Demo.dir/main.cc.o</span><br><span class="line">Linking C executable Demo</span><br><span class="line">[100%] Built target Demo</span><br><span class="line">[ehome@xman Demo1]$ ./Demo 5 4</span><br><span class="line">5 ^ 4 is 625</span><br><span class="line">[ehome@xman Demo1]$ ./Demo 7 3</span><br><span class="line">7 ^ 3 is 343</span><br><span class="line">[ehome@xman Demo1]$ ./Demo 2 10</span><br><span class="line">2 ^ 10 is 1024</span><br></pre></td></tr></table></figure></p><h2 id="多个源文件"><a href="#多个源文件" class="headerlink" title="多个源文件"></a>多个源文件</h2><h3 id="同一目录，多个源文件"><a href="#同一目录，多个源文件" class="headerlink" title="同一目录，多个源文件"></a>同一目录，多个源文件</h3><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo2.zip" title="源码下载">Demo2</a>。</p>          </div><p>现在假如把 <span class="label danger">power</span> 函数单独写进一个名为 <span class="label danger">MathFunctions.cc</span> 的源文件里<br>将上述工程修改下</p><p>MathFunctions.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* power - Calculate the power of number.</span><br><span class="line">* @param base: Base value.</span><br><span class="line">* @param exponent: Exponent value.</span><br><span class="line">*</span><br><span class="line">* @return base raised to the power exponent.</span><br><span class="line">*/</span><br><span class="line">double power(double base, int exponent);</span><br></pre></td></tr></table></figure><p>MathFunctions.cc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* power - Calculate the power of number.</span><br><span class="line">* @param base: Base value.</span><br><span class="line">* @param exponent: Exponent value.</span><br><span class="line">*</span><br><span class="line">* @return base raised to the power exponent.</span><br><span class="line">*/</span><br><span class="line">double power(double base, int exponent)</span><br><span class="line">&#123;</span><br><span class="line">    int result = base;</span><br><span class="line">    int i;</span><br><span class="line">    if (exponent == 0) &#123;</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    for(i = 1; i &lt; exponent; ++i)&#123;</span><br><span class="line">        result = result * base;</span><br><span class="line">    &#125;</span><br><span class="line">    return result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>main.cc</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;MathFunctions.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个时候，CMakeLists.txt 可以改成如下的形式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc MathFunctions.cc)</span><br></pre></td></tr></table></figure><p>文件目录结构如下<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo2 iddd$ tree -L 2</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- MathFunctions.cc</span><br><span class="line">|-- MathFunctions.h</span><br><span class="line">`-- main.cc</span><br></pre></td></tr></table></figure></p><p>唯一的改动只是在 <span class="label danger">add_executable</span> 命令中增加了一个 <span class="label danger">MathFunctions.cc</span> 源文件。</p><p>存在问题：</p><pre><code>- 如果源文件很多，把所有源文件的名字都加进去将是一件烦人的工作。</code></pre><p>更省事的方法是使用 <span class="label danger">aux_source_directory</span> 命令，该命令会查找指定目录下的所有源文件，然后将结果存进指定变量名。其语法如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">aux_source_directory(&lt;dir&gt; &lt;variable&gt;)</span><br></pre></td></tr></table></figure><p>因此，可以修改 CMakeLists.txt 如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo2)</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>这样，CMake 会将当前目录所有源文件的文件名赋值给变量 <span class="label danger">DIR_SRCS</span>  ，再指示变量 <span class="label danger">DIR_SRCS</span> 中的源文件需要编译成一个名称为 Demo 的可执行文件。</p><h3 id="多个目录，多个源文件"><a href="#多个目录，多个源文件" class="headerlink" title="多个目录，多个源文件"></a>多个目录，多个源文件</h3><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo3.zip" title="源码下载">Demo3</a>。</p>          </div><p>现在进一步将 MathFunctions.h 和 MathFunctions.cc 文件移动到 math 目录下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo3 iddd$ tree -L 2</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- main.cc</span><br><span class="line">`-- math</span><br><span class="line">    |-- CMakeLists.txt</span><br><span class="line">    |-- MathFunctions.cc</span><br><span class="line">    |-- MathFunctions.h</span><br></pre></td></tr></table></figure><p>修改main.cc<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;math/MathFunctions.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>对于这种情况，需要分别在项目根目录 Demo3 和 math 目录里各编写一个 CMakeLists.txt 文件。为了方便，我们可以先将 math 目录里的文件编译成静态库再由 main 函数调用。</p><p>根目录中的 CMakeLists.txt ：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo3)</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 添加 math 子目录</span><br><span class="line">add_subdirectory(math)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo main.cc)</span><br><span class="line"># 添加链接库</span><br><span class="line">target_link_libraries(Demo MathFunctions)</span><br></pre></td></tr></table></figure><p>该文件添加了下面的内容: 第3行，使用命令 <span class="label danger">add_subdirectory</span> 指明本项目包含一个子目录 math，这样 math 目录下的 CMakeLists.txt 文件和源代码也会被处理 。第6行，使用命令 <span class="label danger">target_link_libraries</span> 指明可执行文件 main 需要连接一个名为 MathFunctions 的链接库 。</p><p>子目录中的 CMakeLists.txt：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_LIB_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_LIB_SRCS)</span><br><span class="line"># 生成链接库</span><br><span class="line">add_library (MathFunctions $&#123;DIR_LIB_SRCS&#125;)</span><br></pre></td></tr></table></figure><p>在该文件中使用命令 <span class="label danger">add_library</span> 将 src 目录中的源文件编译为静态链接库。</p><h2 id="自定义编译选项"><a href="#自定义编译选项" class="headerlink" title="自定义编译选项"></a>自定义编译选项</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo4.zip" title="源码下载">Demo4</a>。</p>          </div><p>CMake 允许为项目增加编译选项，从而可以根据用户的环境和需求选择最合适的编译方案。<br>例如，可以将 MathFunctions 库设为一个可选的库，如果该选项为 <span class="label danger">ON</span> ，就使用该库定义的数学函数来进行运算。否则就调用标准库中的数学函数库。</p><h3 id="修改-CMakeLists-文件"><a href="#修改-CMakeLists-文件" class="headerlink" title="修改 CMakeLists 文件"></a>修改 CMakeLists 文件</h3><p>我们要做的第一步是在顶层的 CMakeLists.txt 文件中添加该选项：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"># CMake 最低版本号要求</span><br><span class="line">cmake_minimum_required (VERSION 2.8)</span><br><span class="line"># 项目信息</span><br><span class="line">project (Demo4)</span><br><span class="line"># 加入一个配置头文件，用于处理 CMake 对源码的设置</span><br><span class="line">configure_file (</span><br><span class="line">&quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;</span><br><span class="line">&quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span><br><span class="line">)</span><br><span class="line"># 是否使用自己的 MathFunctions 库</span><br><span class="line">option (USE_MYMATH</span><br><span class="line">&quot;Use provided math implementation&quot; ON)</span><br><span class="line"># 是否加入 MathFunctions 库</span><br><span class="line">if (USE_MYMATH)</span><br><span class="line">include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;)</span><br><span class="line">add_subdirectory (math)</span><br><span class="line">set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)</span><br><span class="line">endif (USE_MYMATH)</span><br><span class="line"># 查找当前目录下的所有源文件</span><br><span class="line"># 并将名称保存到 DIR_SRCS 变量</span><br><span class="line">aux_source_directory(. DIR_SRCS)</span><br><span class="line"># 指定生成目标</span><br><span class="line">add_executable(Demo $&#123;DIR_SRCS&#125;)</span><br><span class="line">target_link_libraries (Demo $&#123;EXTRA_LIBS&#125;)</span><br></pre></td></tr></table></figure></p><p>其中：</p><ol><li>第7行的 <span class="label danger">configure_file</span>  命令用于加入一个配置头文件 config.h ，这个文件由 CMake 从 <span class="label info">config.h.in</span> 生成，通过这样的机制，将可以通过预定义一些参数和变量来控制代码的生成。</li><li>第13行的 <span class="label danger">option</span> 命令添加了一个 <span class="label danger">USE_MYMATH</span> 选项，并且默认值为 <span class="label danger">ON</span> 。</li><li>第17行根据 <span class="label danger">USE_MYMATH</span> 变量的值来决定是否使用我们自己编写的 MathFunctions 库。</li></ol><h3 id="修改-main-cc-文件"><a href="#修改-main-cc-文件" class="headerlink" title="修改 main.cc 文件"></a>修改 main.cc 文件</h3><p>代码中添加编译选项 宏定义 <span class="label danger">USE_MYMATH</span></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line"></span><br><span class="line">#ifdef USE_MYMATH</span><br><span class="line">#include &quot;math/MathFunctions.h&quot;</span><br><span class="line">#else</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line"></span><br><span class="line">#ifdef USE_MYMATH</span><br><span class="line">    printf(&quot;Now we use our own Math library. \n&quot;);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">#else</span><br><span class="line">    printf(&quot;Now we use the standard library. \n&quot;);</span><br><span class="line">    double result = pow(base, exponent);</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="编写-文件"><a href="#编写-文件" class="headerlink" title="编写   文件"></a>编写 <span class="label info">config.h.in</span>  文件</h3><p>上面的程序值得注意的是第2行，这里引用了一个 config.h 文件，这个文件预定义了 <span class="label danger">USE_MYMATH</span> 的值。但我们并不直接编写这个文件，为了方便从 CMakeLists.txt 中导入配置，我们编写一个 <span class="label info">config.h.in</span> 文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#cmakedefine USE_MYMATH</span><br></pre></td></tr></table></figure><p>这样 CMake 会自动根据 CMakeLists 配置文件中的设置自动生成 config.h 文件。</p><h3 id="编译项目-1"><a href="#编译项目-1" class="headerlink" title="编译项目"></a>编译项目</h3><p>现在编译一下这个项目，为了便于交互式的选择该变量的值，可以使用 <span class="label danger">ccmake</span> 命令, 该命令会提供一个会话式的交互式配置界面。：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ccmake .</span><br></pre></td></tr></table></figure><img src="/2020/11/13/cpp/cpp-cmake-0/ccmake-0.png" class="" title="交互式配置界面"><p>从中可以找到刚刚定义的 <span class="label danger">USE_MYMATH</span> 选项，按键盘的方向键可以在不同的选项窗口间跳转，按下 <span class="label danger">enter</span>  键可以修改该选项。修改完成后可以按下 <span class="label danger">c</span>  选项完成配置，之后再按 <span class="label danger">g</span> 键确认生成 Makefile 。</p><p>ccmake 的其他操作可以参考窗口下方给出的指令提示。</p><p>我们可以试试分别将 <span class="label danger">USE_MYMATH</span> 设为 <span class="label danger">ON</span> 和 <span class="label danger">OFF</span> 得到的结果：</p><h3 id="为"><a href="#为" class="headerlink" title=" 为 "></a><span class="label danger">USE_MYMATH</span> 为 <span class="label danger">ON</span></h3><p>config.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#define USE_MYMATH</span><br></pre></td></tr></table></figure><p>运行结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo4 iddd$ ./Demo 4 8</span><br><span class="line">Now we use our own Math library.</span><br><span class="line">4 ^ 8 is 65536</span><br></pre></td></tr></table></figure></p><h3 id="为-1"><a href="#为-1" class="headerlink" title=" 为 "></a><span class="label danger">USE_MYMATH</span> 为 <span class="label danger">OFF</span></h3><p>config.h</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/* #undef USE_MYMATH */</span><br></pre></td></tr></table></figure><p>运行结果<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo4 iddd$ ./Demo 4 8</span><br><span class="line">Now we use the standard library.</span><br><span class="line">4 ^ 8 is 65536</span><br></pre></td></tr></table></figure></p><h2 id="安装和测试"><a href="#安装和测试" class="headerlink" title="安装和测试"></a>安装和测试</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo5.zip" title="源码下载">Demo5</a>。</p>          </div><p>CMake 也可以指定安装规则，以及添加测试。这两个功能分别可以通过在产生 Makefile 后使用 <span class="label danger">make install</span> 和 <span class="label danger">make test</span> 来执行。在以前的 GNU Makefile 里，你可能需要为此编写 <span class="label danger">install</span> 和 <span class="label danger">test</span> 两个伪目标和相应的规则，但在 CMake 里，这样的工作同样只需要简单的调用几条命令。</p><h3 id="定制安装规则"><a href="#定制安装规则" class="headerlink" title="定制安装规则"></a>定制安装规则</h3><p>首先先在 math/CMakeLists.txt 文件里添加下面两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 指定 MathFunctions 库的安装路径</span><br><span class="line">install (TARGETS MathFunctions DESTINATION bin)</span><br><span class="line">install (FILES MathFunctions.h DESTINATION include)</span><br></pre></td></tr></table></figure><p>指明 MathFunctions 库的安装路径。之后同样修改根目录的 CMakeLists 文件，在末尾添加下面几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># 指定安装路径</span><br><span class="line"></span><br><span class="line">install (TARGETS Demo DESTINATION bin)</span><br><span class="line">install (FILES &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span><br><span class="line">DESTINATION include)</span><br></pre></td></tr></table></figure><p>通过上面的定制，生成的 Demo 文件和 MathFunctions 函数库 libMathFunctions.o 文件将会被复制到 <span class="label danger">/usr/local/bin</span> 中，而 MathFunctions.h 和生成的 config.h 文件则会被复制到 <span class="label danger">/usr/local/include</span> 中。</p><h3 id="我们可以验证一下"><a href="#我们可以验证一下" class="headerlink" title="我们可以验证一下"></a>我们可以验证一下</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo5 iddd$ make install</span><br><span class="line">[ 50%] Built target MathFunctions</span><br><span class="line">[100%] Built target Demo</span><br><span class="line">Install the project...</span><br><span class="line">-- Install configuration: &quot;&quot;</span><br><span class="line">-- Installing: /usr/local/bin/Demo</span><br><span class="line">-- Installing: /usr/local/include/config.h</span><br><span class="line">-- Installing: /usr/local/bin/libMathFunctions.a</span><br><span class="line">-- Installing: /usr/local/include/MathFunctions.h</span><br><span class="line">iddddeMac-mini:Demo5 iddd$ ls /usr/local/bin/Demo</span><br><span class="line">/usr/local/bin/Demo</span><br><span class="line">iddddeMac-mini:Demo5 iddd$ ls /usr/local/bin/libMathFunctions.a</span><br><span class="line">/usr/local/bin/libMathFunctions.a</span><br><span class="line">iddddeMac-mini:Demo5 iddd$ ls /usr/local/include/config.h</span><br><span class="line">/usr/local/include/config.h</span><br><span class="line">iddddeMac-mini:Demo5 iddd$ ls /usr/local/include/MathFunctions.h</span><br><span class="line">/usr/local/include/MathFunctions.h</span><br></pre></td></tr></table></figure><p>顺带一提的是，这里的 <span class="label danger">/usr/local/</span> 是默认安装到的根目录，可以通过修改 <span class="label danger">CMAKE_INSTALL_PREFIX</span> 变量的值来指定这些文件应该拷贝到哪个根目录。</p><h3 id="卸载安装的软件"><a href="#卸载安装的软件" class="headerlink" title="卸载安装的软件"></a>卸载安装的软件</h3><p>通过CMake 安装的软件都会有一个安装文件列表</p><p>install_manifest.txt 内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">/usr/local/bin/Demo</span><br><span class="line">/usr/local/include/config.h</span><br><span class="line">/usr/local/bin/libMathFunctions.a</span><br><span class="line">/usr/local/include/MathFunctions.h</span><br></pre></td></tr></table></figure><p>只要删除就好<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat install_manifest.txt |xargs rm</span><br></pre></td></tr></table></figure></p><h3 id="为工程添加测试"><a href="#为工程添加测试" class="headerlink" title="为工程添加测试"></a>为工程添加测试</h3><p>添加测试同样很简单。CMake 提供了一个称为 CTest 的测试工具。我们要做的只是在项目根目录的 CMakeLists 文件中调用一系列的 add_test 命令。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"># 启用测试</span><br><span class="line">enable_testing()</span><br><span class="line"></span><br><span class="line"># 测试程序是否成功运行</span><br><span class="line">add_test (test_run Demo 5 2)</span><br><span class="line"></span><br><span class="line"># 测试帮助信息是否可以正常提示</span><br><span class="line">add_test (test_usage Demo)</span><br><span class="line">set_tests_properties (test_usage</span><br><span class="line">  PROPERTIES PASS_REGULAR_EXPRESSION &quot;Usage: .* base exponent&quot;)</span><br><span class="line"></span><br><span class="line"># 测试 5 的平方</span><br><span class="line">add_test (test_5_2 Demo 5 2)</span><br><span class="line"></span><br><span class="line">set_tests_properties (test_5_2</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 25&quot;)</span><br><span class="line"></span><br><span class="line"># 测试 10 的 5 次方</span><br><span class="line">add_test (test_10_5 Demo 10 5)</span><br><span class="line"></span><br><span class="line">set_tests_properties (test_10_5</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 100000&quot;)</span><br><span class="line"></span><br><span class="line"># 测试 2 的 10 次方</span><br><span class="line">add_test (test_2_10 Demo 2 10)</span><br><span class="line"></span><br><span class="line">set_tests_properties (test_2_10</span><br><span class="line"> PROPERTIES PASS_REGULAR_EXPRESSION &quot;is 1024&quot;)</span><br></pre></td></tr></table></figure><p>上面的代码包含了四个测试。第一个测试 <span class="label danger">test_run</span>  用来测试程序是否成功运行并返回 0 值。剩下的三个测试分别用来测试 5 的 平方、10 的 5 次方、2 的 10 次方是否都能得到正确的结果。其中 <span class="label danger">PASS_REGULAR_EXPRESSION</span>   用来测试输出是否包含后面跟着的字符串。</p><p>让我们看看测试的结果：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo5 iddd$ cmake .</span><br><span class="line">-- Configuring done</span><br><span class="line">-- Generating done</span><br><span class="line">-- Build files have been written to: /Users/iddd/Test/Demo5</span><br><span class="line">iddddeMac-mini:Demo5 iddd$ make test</span><br><span class="line">Running tests...</span><br><span class="line">Test project /Users/iddd/Test/Demo5</span><br><span class="line">    Start 1: test_run</span><br><span class="line">1/5 Test #1: test_run .........................   Passed    0.62 sec</span><br><span class="line">    Start 2: test_usage</span><br><span class="line">2/5 Test #2: test_usage .......................   Passed    0.00 sec</span><br><span class="line">    Start 3: test_5_2</span><br><span class="line">3/5 Test #3: test_5_2 .........................   Passed    0.00 sec</span><br><span class="line">    Start 4: test_10_5</span><br><span class="line">4/5 Test #4: test_10_5 ........................   Passed    0.00 sec</span><br><span class="line">    Start 5: test_2_10</span><br><span class="line">5/5 Test #5: test_2_10 ........................   Passed    0.00 sec</span><br><span class="line"></span><br><span class="line">100% tests passed, 0 tests failed out of 5</span><br><span class="line"></span><br><span class="line">Total Test time (real) =   0.63 sec</span><br><span class="line">iddddeMac-mini:Demo5 iddd$</span><br></pre></td></tr></table></figure></p><p>如果要测试更多的输入数据，像上面那样一个个写测试用例未免太繁琐。这时可以通过编写宏来实现：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># 定义一个宏，用来简化测试工作</span><br><span class="line">macro (do_test arg1 arg2 result)</span><br><span class="line">  add_test (test_$&#123;arg1&#125;_$&#123;arg2&#125; Demo $&#123;arg1&#125; $&#123;arg2&#125;)</span><br><span class="line">  set_tests_properties (test_$&#123;arg1&#125;_$&#123;arg2&#125;</span><br><span class="line">    PROPERTIES PASS_REGULAR_EXPRESSION $&#123;result&#125;)</span><br><span class="line">endmacro (do_test)</span><br><span class="line"> </span><br><span class="line"># 使用该宏进行一系列的数据测试</span><br><span class="line">do_test (5 2 &quot;is 25&quot;)</span><br><span class="line">do_test (10 5 &quot;is 100000&quot;)</span><br><span class="line">do_test (2 10 &quot;is 1024&quot;)</span><br></pre></td></tr></table></figure><p>关于 CTest 的更详细的用法可以通过 <span class="label danger">man 1 ctest</span>   参考 CTest 的文档。</p><h2 id="支持-gdb"><a href="#支持-gdb" class="headerlink" title="支持 gdb"></a>支持 gdb</h2><p>让 CMake 支持 gdb 的设置也很容易，只需要指定 <span class="label danger">Debug</span> 模式下开启 <span class="label danger">-g</span> 选项：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">set(CMAKE_BUILD_TYPE &quot;Debug&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_DEBUG &quot;$ENV&#123;CXXFLAGS&#125; -O0 -Wall -g -ggdb&quot;)</span><br><span class="line">set(CMAKE_CXX_FLAGS_RELEASE &quot;$ENV&#123;CXXFLAGS&#125; -O3 -Wall&quot;)</span><br></pre></td></tr></table></figure><p>之后可以直接对生成的程序使用 gdb 来调试。</p><h2 id="添加环境检查"><a href="#添加环境检查" class="headerlink" title="添加环境检查"></a>添加环境检查</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo6.zip" title="源码下载">Demo6</a>。</p>          </div><p>有时候可能要对系统环境做点检查，例如要使用一个平台相关的特性的时候。在这个例子中，我们检查系统是否自带 pow 函数。如果带有 pow 函数，就使用它；否则使用我们定义的 power 函数。</p><h3 id="添加-CheckFunctionExists-宏"><a href="#添加-CheckFunctionExists-宏" class="headerlink" title="添加 CheckFunctionExists 宏"></a>添加 CheckFunctionExists 宏</h3><p>首先在顶层 CMakeLists 文件中添加 CheckFunctionExists.cmake 宏，并调用 <span class="label danger">check_function_exists</span> 命令测试链接器是否能够在链接阶段找到 <span class="label danger">pow</span> 函数。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"># Project Info</span><br><span class="line">project (Demo6)</span><br><span class="line"></span><br><span class="line">set (CMAKE_INCLUDE_CURRENT_DIR ON)</span><br><span class="line"></span><br><span class="line"># 检查系统是否支持 pow 函数</span><br><span class="line">include ($&#123;CMAKE_ROOT&#125;/Modules/CheckFunctionExists.cmake)</span><br><span class="line">check_function_exists (pow HAVE_POW)</span><br><span class="line"></span><br><span class="line"># Add Configure</span><br><span class="line">configure_file (</span><br><span class="line">    &quot;$&#123;PROJECT_SOURCE_DIR&#125;/config.h.in&quot;</span><br><span class="line">    &quot;$&#123;PROJECT_BINARY_DIR&#125;/config.h&quot;</span><br><span class="line">    )</span><br><span class="line"></span><br><span class="line"># Use Option USE_MYMATH</span><br><span class="line">if (NOT HAVE_POW)</span><br><span class="line">    include_directories (&quot;$&#123;PROJECT_SOURCE_DIR&#125;/math&quot;)</span><br><span class="line">    add_subdirectory (math)</span><br><span class="line">    set (EXTRA_LIBS $&#123;EXTRA_LIBS&#125; MathFunctions)</span><br><span class="line">endif (NOT HAVE_POW)</span><br></pre></td></tr></table></figure><p>将上面这段代码放在 <span class="label danger">configure_file</span>  命令前。</p><h3 id="预定义相关宏变量"><a href="#预定义相关宏变量" class="headerlink" title="预定义相关宏变量"></a>预定义相关宏变量</h3><p>接下来修改 config.h.in 文件，预定义相关的宏变量。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// does the platform provide pow function?</span><br><span class="line">#cmakedefine HAVE_POW</span><br></pre></td></tr></table></figure><h3 id="在代码中使用宏和函数"><a href="#在代码中使用宏和函数" class="headerlink" title="在代码中使用宏和函数"></a>在代码中使用宏和函数</h3><p>最后一步是修改 main.cc ，在代码中使用宏和函数：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#ifdef HAVE_POW</span><br><span class="line">  #include &lt;math.h&gt;</span><br><span class="line">#else</span><br><span class="line">  #include &lt;math/MathFunctions.h&gt;</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">#ifdef HAVE_POW</span><br><span class="line">    printf(&quot;Now we use the standard library. \n&quot;);</span><br><span class="line">    double result = pow(base, exponent);</span><br><span class="line">#else</span><br><span class="line">    printf(&quot;Now we use our own Math library. \n&quot;);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">#endif</span><br></pre></td></tr></table></figure><h2 id="添加版本号"><a href="#添加版本号" class="headerlink" title="添加版本号"></a>添加版本号</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo7.zip" title="源码下载">Demo7</a>。</p>          </div><p>给项目添加和维护版本号是一个好习惯，这样有利于用户了解每个版本的维护情况，并及时了解当前所用的版本是否过时，或是否可能出现不兼容的情况。</p><p>首先修改顶层 CMakeLists 文件，在 <span class="label danger">project</span> 命令之后加入如下两行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set (Demo_VERSION_MAJOR 1)</span><br><span class="line">set (Demo_VERSION_MINOR 0)</span><br></pre></td></tr></table></figure><p>分别指定当前的项目的主版本号和副版本号。</p><p>之后，为了在代码中获取版本信息，我们可以修改 <span class="label info">config.h.in</span>  文件，添加两个预定义变量：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// the configured options and settings for Tutorial</span><br><span class="line">#define Demo_VERSION_MAJOR @Demo_VERSION_MAJOR@</span><br><span class="line">#define Demo_VERSION_MINOR @Demo_VERSION_MINOR@</span><br></pre></td></tr></table></figure><p>这样就可以直接在代码中打印版本信息了：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">#include &lt;math.h&gt;</span><br><span class="line">#include &quot;config.h&quot;</span><br><span class="line">#include &quot;math/MathFunctions.h&quot;</span><br><span class="line"></span><br><span class="line">int main(int argc, char *argv[])</span><br><span class="line">&#123;</span><br><span class="line">    if (argc &lt; 3)&#123;</span><br><span class="line">        // print version info</span><br><span class="line">        printf(&quot;%s Version %d.%d\n&quot;,</span><br><span class="line">            argv[0],</span><br><span class="line">            Demo_VERSION_MAJOR,</span><br><span class="line">            Demo_VERSION_MINOR);</span><br><span class="line">        printf(&quot;Usage: %s base exponent \n&quot;, argv[0]);</span><br><span class="line">        return 1;</span><br><span class="line">    &#125;</span><br><span class="line">    double base = atof(argv[1]);</span><br><span class="line">    int exponent = atoi(argv[2]);</span><br><span class="line">    double result = power(base, exponent);</span><br><span class="line">    printf(&quot;%g ^ %d is %g\n&quot;, base, exponent, result);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo7 iddd$ ./Demo</span><br><span class="line">./Demo Version 1.0</span><br><span class="line">Usage: ./Demo base exponent</span><br></pre></td></tr></table></figure><h2 id="生成安装包"><a href="#生成安装包" class="headerlink" title="生成安装包"></a>生成安装包</h2><div class="note info">            <p>本节对应的源代码所在目录：<a href="Demo8.zip" title="源码下载">Demo8</a>。</p>          </div><p>本节将学习如何配置生成各种平台上的安装包，包括二进制安装包和源码安装包。为了完成这个任务，我们需要用到 CPack ，它同样也是由 CMake 提供的一个工具，专门用于打包。</p><p>首先在顶层的 CMakeLists.txt 文件尾部添加下面几行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># 构建一个 CPack 安装包</span><br><span class="line">include (InstallRequiredSystemLibraries)</span><br><span class="line">set (CPACK_RESOURCE_FILE_LICENSE</span><br><span class="line">  &quot;$&#123;CMAKE_CURRENT_SOURCE_DIR&#125;/License.txt&quot;)</span><br><span class="line">set (CPACK_PACKAGE_VERSION_MAJOR &quot;$&#123;Demo_VERSION_MAJOR&#125;&quot;)</span><br><span class="line">set (CPACK_PACKAGE_VERSION_MINOR &quot;$&#123;Demo_VERSION_MINOR&#125;&quot;)</span><br><span class="line">include (CPack)</span><br></pre></td></tr></table></figure><p>上面的代码做了以下几个工作：</p><ol><li>导入 <span class="label danger">InstallRequiredSystemLibraries</span> 模块，以便之后导入 <span class="label danger">CPack</span> 模块；</li><li>设置一些 <span class="label danger">CPack</span> 相关变量，包括版权信息和版本信息，其中版本信息用了上一节定义的版本号；</li><li>导入 <span class="label danger">CPack</span> 模块。</li></ol><p>添加 License.txt 文件,内容无所谓</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">BSD 2</span><br></pre></td></tr></table></figure><p>文件结构<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo8 iddd$ tree -L 2</span><br><span class="line">.</span><br><span class="line">|-- CMakeLists.txt</span><br><span class="line">|-- License.txt</span><br><span class="line">|-- config.h.in</span><br><span class="line">|-- main.cc</span><br><span class="line">`-- math</span><br><span class="line">    |-- CMakeLists.txt</span><br><span class="line">    |-- MathFunctions.cc</span><br><span class="line">    `-- MathFunctions.h</span><br></pre></td></tr></table></figure><br>接下来的工作是像往常一样构建工程，并执行 <span class="label danger">cpack</span> 命令。</p><p>生成二进制安装包：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpack -C CPackConfig.cmake</span><br></pre></td></tr></table></figure><br>生成源码安装包<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cpack -C CPackSourceConfig.cmake</span><br></pre></td></tr></table></figure><br>我们可以试一下。在生成项目后，执行 <span class="label danger">cpack -C CPackConfig.cmake</span> 命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo8 iddd$ cpack -C CPackConfig.cmake</span><br><span class="line">CPack: Create package using STGZ</span><br><span class="line">CPack: Install projects</span><br><span class="line">CPack: - Run preinstall target for: Demo8</span><br><span class="line">CPack: - Install project: Demo8 [CPackConfig.cmake]</span><br><span class="line">CPack: Create package</span><br><span class="line">CPack: - package: /Users/iddd/Test/Demo8/Demo8-1.0.1-Darwin.sh generated.</span><br><span class="line">CPack: Create package using TGZ</span><br><span class="line">CPack: Install projects</span><br><span class="line">CPack: - Run preinstall target for: Demo8</span><br><span class="line">CPack: - Install project: Demo8 [CPackConfig.cmake]</span><br><span class="line">CPack: Create package</span><br><span class="line">CPack: - package: /Users/iddd/Test/Demo8/Demo8-1.0.1-Darwin.tar.gz generated.</span><br></pre></td></tr></table></figure><p>我们可以执行其中一个。此时会出现一个由 CPack 自动生成的交互式安装界面：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo8 iddd$ sh Demo8-1.0.1-Darwin.sh</span><br><span class="line">Demo8 Installer Version: 1.0.1, Copyright (c) Humanity</span><br><span class="line">This is a self-extracting archive.</span><br><span class="line">The archive will be extracted to: /Users/iddd/Test/Demo8</span><br><span class="line"></span><br><span class="line">If you want to stop extracting, please press &lt;ctrl-C&gt;.</span><br><span class="line">BSD 2</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Do you accept the license? [yn]:</span><br><span class="line">y</span><br><span class="line">By default the Demo8 will be installed in:</span><br><span class="line">  &quot;/Users/iddd/Test/Demo8/Demo8-1.0.1-Darwin&quot;</span><br><span class="line">Do you want to include the subdirectory Demo8-1.0.1-Darwin?</span><br><span class="line">Saying no will install in: &quot;/Users/iddd/Test/Demo8&quot; [Yn]:</span><br><span class="line">y</span><br><span class="line"></span><br><span class="line">Using target directory: /Users/iddd/Test/Demo8/Demo8-1.0.1-Darwin</span><br><span class="line">Extracting, please wait...</span><br><span class="line"></span><br><span class="line">Unpacking finished successfully</span><br></pre></td></tr></table></figure><br>完成后提示安装到了 Demo8-1.0.1-Darwin 子目录中，我们可以进去执行该程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">iddddeMac-mini:Demo8 iddd$ ./Demo8-1.0.1-Darwin/bin/Demo 6 7</span><br><span class="line">6 ^ 7 is 279936</span><br></pre></td></tr></table></figure><p>关于 CPack 的更详细的用法可以通过 <span class="label danger">man 1 cpack</span> 参考 CPack 的文档。</p><h2 id="将其他平台项目迁移到CMake"><a href="#将其他平台项目迁移到CMake" class="headerlink" title="将其他平台项目迁移到CMake"></a>将其他平台项目迁移到CMake</h2><p>CMake 可以很轻松地构建出在适合各个平台执行的工程环境。而如果当前的工程环境不是 CMake ，而是基于某个特定的平台，是否可以迁移到 CMake 呢？答案是可能的。下面针对几个常用的平台，列出了它们对应的迁移方案。</p><h3 id="autotools"><a href="#autotools" class="headerlink" title="autotools"></a>autotools</h3><ul><li><a href="https://projects.kde.org/projects/kde/kdesdk/kde-dev-scripts/repository/revisions/master/changes/cmake-utils/scripts/am2cmake">am2cmake</a> 可以将 autotools 系的项目转换到 CMake，这个工具的一个成功案例是 KDE 。</li><li><a href="http://emanuelgreisen.dk/stuff/kdevelop_am2cmake.php.tgz">Alternative Automake2CMake</a> 可以转换使用 automake 的 KDevelop 工程项目。</li><li><a href="http://www.cmake.org/Wiki/GccXmlAutoConfHints">Converting autoconf tests</a></li></ul><h3 id="qmake"><a href="#qmake" class="headerlink" title="qmake"></a>qmake</h3><p><a href="http://www.cmake.org/Wiki/CMake:ConvertFromQmake">qmake converter</a> 可以转换使用 QT 的 qmake 的工程。</p><h3 id="Visual-Studio"><a href="#Visual-Studio" class="headerlink" title="Visual Studio"></a>Visual Studio</h3><ul><li><a href="http://vcproj2cmake.sf.net/">vcproj2cmake.rb</a> 可以根据 Visual Studio 的工程文件（后缀名是 .vcproj 或 .vcxproj）生成 CMakeLists.txt 文件。</li><li><a href="http://nberserk.blogspot.com/2010/11/converting-vc-projectsvcproj-to.html">vcproj2cmake.ps1</a> vcproj2cmake 的 PowerShell 版本。</li><li><a href="http://sourceforge.net/projects/folders4cmake/">folders4cmake</a> 根据 Visual Studio 项目文件生成相应的 “source_group” 信息，这些信息可以很方便的在 CMake 脚本中使用。支持 Visual Studio 9/10 工程文件。</li></ul><h3 id="CMakeLists-txt-自动推导"><a href="#CMakeLists-txt-自动推导" class="headerlink" title="CMakeLists.txt 自动推导"></a>CMakeLists.txt 自动推导</h3><ul><li><a href="http://websvn.kde.org/trunk/KDE/kdesdk/cmake/scripts/">gencmake</a> 根据现有文件推导 CMakeLists.txt 文件。</li><li><a href="http://www.vanvelzensoftware.com/postnuke/index.php?name=Downloads&amp;req=viewdownload&amp;cid=7">CMakeListGenerator</a> 应用一套文件和目录分析创建出完整的 CMakeLists.txt 文件。仅支持 Win32 平台。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ul><li><a href="https://www.hahack.com/codes/cmake/">CMake 入门实战</a></li><li><a href="https://blog.csdn.net/zhuiyunzhugang/article/details/88142908">超详细的cmake教程</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;你或许听过好几种 Make 工具，例如 &lt;a href=&quot;https://www.hahack.com/wiki/tools-makefile.html&quot;&gt;GNU Make&lt;/a&gt; ，QT 的 &lt;a href=&quot;http://qt-project.org/doc/qt-4.8/qmake-manual.html&quot;&gt;qmake&lt;/a&gt; ，微软的 &lt;a href=&quot;http://msdn.microsoft.com/en-us/library/ms930369.aspx&quot;&gt;MS nmake&lt;/a&gt;，BSD Make（&lt;a href=&quot;http://www.freebsd.org/doc/en/books/pmake/&quot;&gt;pmake&lt;/a&gt;），Makepp，等等。这些 Make 工具遵循着不同的规范和标准，所执行的 Makefile 格式也千差万别。这样就带来了一个严峻的问题：如果软件想跨平台，必须要保证能够在不同平台编译。而如果使用上面的 Make 工具，就得为每一种标准写一次 Makefile ，这将是一件让人抓狂的工作。&lt;/p&gt;
&lt;p&gt;CMake就是针对上面问题所设计的工具：它首先允许开发者编写一种平台无关的 CMakeList.txt 文件来定制整个编译流程，然后再根据目标用户的平台进一步生成所需的本地化 Makefile 和工程文件，如 Unix 的 Makefile 或 Windows 的 Visual Studio 工程。从而做到“Write once, run everywhere”。显然，CMake 是一个比上述几种 make 更高级的编译配置工具。一些使用 CMake 作为项目架构系统的知名开源项目有 VTK、ITK、KDE、OpenCV、OSG 等 [1]。&lt;/p&gt;
&lt;p&gt;在 linux 平台下使用 CMake 生成 Makefile 并编译的流程如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;编写 CMake 配置文件 CMakeLists.txt 。&lt;/li&gt;
&lt;li&gt;执行命令 &lt;span class=&quot;label warning&quot;&gt;cmake PATH&lt;/span&gt; 或者 &lt;span class=&quot;label warning&quot;&gt;ccmake PATH&lt;/span&gt; 生成 Makefile ( &lt;span class=&quot;label warning&quot;&gt;ccmake&lt;/span&gt; 和 &lt;span class=&quot;label warning&quot;&gt;cmake&lt;/span&gt; 的区别在于前者提供了一个交互式的界面)。其中， &lt;span class=&quot;label warning&quot;&gt;PATH&lt;/span&gt; 是 CMakeLists.txt 所在的目录。&lt;/li&gt;
&lt;li&gt;使用 &lt;span class=&quot;label warning&quot;&gt;make&lt;/span&gt; 命令进行编译。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本文将从实例入手，一步步讲解 CMake 的常见用法，文中所有的实例代码可以在这里找到。如果你读完仍觉得意犹未尽，可以继续学习我在文章末尾提供的其他资源。&lt;/p&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习MakeFile(前言)</title>
    <link href="http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-0/"/>
    <id>http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-0/</id>
    <published>2020-11-12T03:39:17.000Z</published>
    <updated>2023-01-06T09:29:19.305Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>为了让逐个编译的过程变成一条命令</p><h2 id="前提：了解Makefile是什么？"><a href="#前提：了解Makefile是什么？" class="headerlink" title="前提：了解Makefile是什么？"></a>前提：了解Makefile是什么？</h2><span class="label danger">Makefile</span>  关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，<span class="label danger">Makefile</span> 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 <span class="label danger">Makefile</span>  就像一个 <span class="label danger">Makefile</span> 脚本一样，其中也可以执行操作系统的命令。<span class="label danger">Makefile</span>  带来的好处就是——“自动化编译”，一旦写好，只需要一个 <span class="label danger">make</span> 命令，整个工程完全自动编译，极大的提高了软件开发的效率。 <span class="label danger">make</span> 是一个命令工具，是一个解释 <span class="label danger">Makefile</span> 中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的 <span class="label danger">make</span> ，Visual C++ 的 <span class="label danger">nmake</span>，Linux下GNU的 <span class="label danger">make</span> 。可见， <span class="label danger">Makefile</span> 都成为了一种在工程方面的编译方法。<blockquote><p>在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。</p></blockquote><span id="more"></span><h2 id="关于编译和链接"><a href="#关于编译和链接" class="headerlink" title="关于编译和链接"></a>关于编译和链接</h2><p>一般来说，无论是C、C++、还是pas，首先要把源文件编译成中间代码文件，在Windows下也就是 .obj 文件，UNIX下是 .o 文件，即 Object File，这个动作叫做编译（compile）。然后再把大量的Object File合成执行文件，这个动作叫作链接（link）。   </p><p>编译时，编译器需要的是语法的正确，函数与变量的声明的正确。对于后者，通常是你需要告诉编译器头文件的所在位置（头文件中应该只是声明，而定义应该放在C/C++文件中），只要所有的语法正确，编译器就可以编译出中间目标文件。一般来说，每个源文件都应该对应于一个中间目标文件（O文件或是OBJ文件）。 </p><p>链接时，主要是链接函数和全局变量，所以，我们可以使用这些中间目标文件（O文件或是OBJ文件）来链接我们的应用程序。链接器并不管函数所在的源文件，只管函数的中间目标文件（Object File），在大多数时候，由于源文件太多，编译生成的中间目标文件太多，而在链接时需要明显地指出中间目标文件名，这对于编译很不方便，所以，我们要给中间目标文件打个包，在Windows下这种包叫“库文件”（Library File)，也就是 .lib 文件，在UNIX下，是Archive File，也就是 .a 文件。</p><blockquote><p>总结一下，源文件首先会生成中间目标文件，再由中间目标文件生成执行文件。在编译时，编译器只检测程序语法，和函数、变量是否被声明。如果函数未被声明，编译器会给出一个警告，但可以生成Object File。而在链接程序时，链接器会在所有的Object File中找寻函数的实现，如果找不到，那到就会报链接错误码（Linker Error），在VC下，这种错误一般是：Link 2001错误，意思说是说，链接器未能找到函数的实现。你需要指定函数的ObjectFile.</p></blockquote><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><ul><li><a href="https://wiki.ubuntu.org.cn/%E8%B7%9F%E6%88%91%E4%B8%80%E8%B5%B7%E5%86%99Makefile">跟我一起写Makefile</a></li><li><a href="https://blog.csdn.net/weixin_38391755/article/details/80380786">Makefile教程（绝对经典，所有问题看这一篇足够了）</a></li></ul><h2 id="MakeFile系列"><a href="#MakeFile系列" class="headerlink" title="MakeFile系列"></a>MakeFile系列</h2><ul><li><a href="/2020/11/12/cpp/cpp-makefile-0/" title="学习MakeFile-前言">学习MakeFile-前言</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-1/" title="学习MakeFile-介绍">学习MakeFile-介绍</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-2/" title="学习MakeFile-总述">学习MakeFile-总述</a>  </li><li><a href="/2020/10/17/cpp/cpp-makefile-3/" title="学习MakeFile-书写规则">学习MakeFile-书写规则</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-simple/" title="学习MakeFile-渐进式">学习MakeFile-渐进式</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;为了让逐个编译的过程变成一条命令&lt;/p&gt;
&lt;h2 id=&quot;前提：了解Makefile是什么？&quot;&gt;&lt;a href=&quot;#前提：了解Makefile是什么？&quot; class=&quot;headerlink&quot; title=&quot;前提：了解Makefile是什么？&quot;&gt;&lt;/a&gt;前提：了解Makefile是什么？&lt;/h2&gt;&lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt;  关系到了整个工程的编译规则。一个工程中的源文件不计数，其按类型、功能、模块分别放在若干个目录中，&lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt; 定义了一系列的规则来指定，哪些文件需要先编译，哪些文件需要后编译，哪些文件需要重新编译，甚至于进行更复杂的功能操作，因为 &lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt;  就像一个 &lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt; 脚本一样，其中也可以执行操作系统的命令。

&lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt;  带来的好处就是——“自动化编译”，一旦写好，只需要一个 &lt;span class=&quot;label danger&quot;&gt;make&lt;/span&gt; 命令，整个工程完全自动编译，极大的提高了软件开发的效率。 

&lt;span class=&quot;label danger&quot;&gt;make&lt;/span&gt; 是一个命令工具，是一个解释 &lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt; 中指令的命令工具，一般来说，大多数的IDE都有这个命令，比如：Delphi的 &lt;span class=&quot;label danger&quot;&gt;make&lt;/span&gt; ，Visual C++ 的 &lt;span class=&quot;label danger&quot;&gt;nmake&lt;/span&gt;，Linux下GNU的 &lt;span class=&quot;label danger&quot;&gt;make&lt;/span&gt; 。可见， &lt;span class=&quot;label danger&quot;&gt;Makefile&lt;/span&gt; 都成为了一种在工程方面的编译方法。

&lt;blockquote&gt;&lt;p&gt;在这篇文档中，将以C/C++的源码作为我们基础，所以必然涉及一些关于C/C++的编译的知识，相关于这方面的内容，还请各位查看相关的编译器的文档。这里所默认的编译器是UNIX下的GCC和CC。&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习MakeFile(总述)</title>
    <link href="http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-2/"/>
    <id>http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-2/</id>
    <published>2020-11-12T03:39:17.000Z</published>
    <updated>2023-01-06T09:29:39.250Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>为了让逐个编译的过程变成一条命令</p><h2 id="2-Makefile-总述"><a href="#2-Makefile-总述" class="headerlink" title="2 Makefile 总述"></a>2 Makefile 总述</h2><h3 id="2-1-Makefile里有什么？"><a href="#2-1-Makefile里有什么？" class="headerlink" title="2.1 Makefile里有什么？"></a>2.1 Makefile里有什么？</h3><p>Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。</p><ol><li>显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。</li><li>隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。</li><li>变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。</li><li>文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。</li><li>注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。</li></ol><p>最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。</p><span id="more"></span><h3 id="2-2-Makefile的文件名"><a href="#2-2-Makefile的文件名" class="headerlink" title="2.2 Makefile的文件名"></a>2.2 Makefile的文件名</h3><p>默认的情况下，make命令会在当前目录下按顺序找寻文件名为“GNUmakefile”、“makefile”、“Makefile”的文件，找到了解释这个文件。在这三个文件名中，最好使用“Makefile”这个文件名，因为，这个文件名第一个字符为大写，这样有一种显目的感觉。最好不要用“GNUmakefile”，这个文件是GNU的make识别的。有另外一些make只对全小写的“makefile”文件名敏感，但是基本上来说，大多数的make都支持“makefile”和“Makefile”这两种默认文件名。</p><p>当然，你可以使用别的文件名来书写Makefile，比如：“Make.Linux”，“Make.Solaris”，“Make.AIX”等，如果要指定特定的Makefile，你可以使用make的“-f”和“—file”参数，如：make -f Make.Linux或make —file Make.AIX。</p><h3 id="2-3-引用其它的Makefile"><a href="#2-3-引用其它的Makefile" class="headerlink" title="2.3 引用其它的Makefile"></a>2.3 引用其它的Makefile</h3><p>在Makefile使用include关键字可以把别的Makefile包含进来，这很像C语言的#include，被包含的文件会原模原样的放在当前文件的包含位置。include的语法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include&lt;filename&gt; </span><br></pre></td></tr></table></figure><p>filename可以是当前操作系统Shell的文件模式（可以保含路径和通配符）</p><p>在include前面可以有一些空字符，但是绝不能是[Tab]键开始。include和可以用一个或多个空格隔开。举个例子，你有这样几个Makefile：a.mk、b.mk、c.mk，还有一个文件叫foo.make，以及一个变量$(bar)，其包含了e.mk和f.mk，那么，下面的语句：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include foo.make *.mk $(bar)</span><br></pre></td></tr></table></figure><p>等价于：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include foo.make a.mk b.mk c.mk e.mk f.mk</span><br></pre></td></tr></table></figure><p>make命令开始时，会把找寻include所指出的其它Makefile，并把其内容安置在当前的位置。就好像C/C++的#include指令一样。如果文件都没有指定绝对路径或是相对路径的话，make会在当前目录下首先寻找，如果当前目录下没有找到，那么，make还会在下面的几个目录下找：</p><p>  1.如果make执行时，有“-I”或“—include-dir”参数，那么make就会在这个参数所指定的目录下去寻找。<br>  2.如果目录/include（一般是：/usr/local/bin或/usr/include）存在的话，make也会去找。</p><p>如果有文件没有找到的话，make会生成一条警告信息，但不会马上出现致命错误。它会继续载入其它的文件，一旦完成makefile的读取，make会再重试这些没有找到，或是不能读取的文件，如果还是不行，make才会出现一条致命信息。如果你想让make不理那些无法读取的文件，而继续执行，你可以在include前加一个减号“-”。如：</p><p>-include<filename></p><p>其表示，无论include过程中出现什么错误，都不要报错继续执行。和其它版本make兼容的相关命令是sinclude，其作用和这一个是一样的。</p><h3 id="2-4-环境变量-MAKEFILES"><a href="#2-4-环境变量-MAKEFILES" class="headerlink" title="2.4 环境变量 MAKEFILES"></a>2.4 环境变量 MAKEFILES</h3><p>如果你的当前环境中定义了环境变量MAKEFILES，那么，make会把这个变量中的值做一个类似于include的动作。这个变量中的值是其它的Makefile，用空格分隔。只是，它和include不同的是，从这个环境变中引入的Makefile的“目标”不会起作用，如果环境变量中定义的文件发现错误，make也会不理。</p><p>但是在这里我还是建议不要使用这个环境变量，因为只要这个变量一被定义，那么当你使用make时，所有的Makefile都会受到它的影响，这绝不是你想看到的。在这里提这个事，只是为了告诉大家，也许有时候你的Makefile出现了怪事，那么你可以看看当前环境中有没有定义这个变量。</p><h2 id="MakeFile系列"><a href="#MakeFile系列" class="headerlink" title="MakeFile系列"></a>MakeFile系列</h2><ul><li><a href="/2020/11/12/cpp/cpp-makefile-0/" title="学习MakeFile-前言">学习MakeFile-前言</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-1/" title="学习MakeFile-介绍">学习MakeFile-介绍</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-2/" title="学习MakeFile-总述">学习MakeFile-总述</a>  </li><li><a href="/2020/10/17/cpp/cpp-makefile-3/" title="学习MakeFile-书写规则">学习MakeFile-书写规则</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-simple/" title="学习MakeFile-渐进式">学习MakeFile-渐进式</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;为了让逐个编译的过程变成一条命令&lt;/p&gt;
&lt;h2 id=&quot;2-Makefile-总述&quot;&gt;&lt;a href=&quot;#2-Makefile-总述&quot; class=&quot;headerlink&quot; title=&quot;2 Makefile 总述&quot;&gt;&lt;/a&gt;2 Makefile 总述&lt;/h2&gt;&lt;h3 id=&quot;2-1-Makefile里有什么？&quot;&gt;&lt;a href=&quot;#2-1-Makefile里有什么？&quot; class=&quot;headerlink&quot; title=&quot;2.1 Makefile里有什么？&quot;&gt;&lt;/a&gt;2.1 Makefile里有什么？&lt;/h3&gt;&lt;p&gt;Makefile里主要包含了五个东西：显式规则、隐晦规则、变量定义、文件指示和注释。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;显式规则。显式规则说明了，如何生成一个或多的的目标文件。这是由Makefile的书写者明显指出，要生成的文件，文件的依赖文件，生成的命令。&lt;/li&gt;
&lt;li&gt;隐晦规则。由于我们的make有自动推导的功能，所以隐晦的规则可以让我们比较粗糙地简略地书写Makefile，这是由make所支持的。&lt;/li&gt;
&lt;li&gt;变量的定义。在Makefile中我们要定义一系列的变量，变量一般都是字符串，这个有点你C语言中的宏，当Makefile被执行时，其中的变量都会被扩展到相应的引用位置上。&lt;/li&gt;
&lt;li&gt;文件指示。其包括了三个部分，一个是在一个Makefile中引用另一个Makefile，就像C语言中的include一样；另一个是指根据某些情况指定Makefile中的有效部分，就像C语言中的预编译#if一样；还有就是定义一个多行的命令。有关这一部分的内容，我会在后续的部分中讲述。&lt;/li&gt;
&lt;li&gt;注释。Makefile中只有行注释，和UNIX的Shell脚本一样，其注释是用“#”字符，这个就像C/C++中的“//”一样。如果你要在你的Makefile中使用“#”字符，可以用反斜框进行转义，如：“#”。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最后，还值得一提的是，在Makefile中的命令，必须要以[Tab]键开始。&lt;/p&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习MakeFile(介绍)</title>
    <link href="http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-1/"/>
    <id>http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-1/</id>
    <published>2020-11-12T03:39:17.000Z</published>
    <updated>2023-01-06T09:29:30.999Z</updated>
    
    <content type="html"><![CDATA[<h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>为了让逐个编译的过程变成一条命令</p><h2 id="1、Makefile-介绍"><a href="#1、Makefile-介绍" class="headerlink" title="1、Makefile 介绍"></a>1、Makefile 介绍</h2><p>make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。</p><p>首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：</p><ol><li>如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。</li><li>如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。</li><li>如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。</li></ol><p>只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。</p><span id="more"></span><h3 id="1-1-Makefile的规则"><a href="#1-1-Makefile的规则" class="headerlink" title="1.1 Makefile的规则"></a>1.1 Makefile的规则</h3><p>在讲述这个Makefile之前，还是让我们先来粗略地看一看Makefile的规则。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">target... : prerequisites ...</span><br><span class="line">  command</span><br><span class="line">    ...</span><br><span class="line">    ...</span><br></pre></td></tr></table></figure><blockquote><p><span class="label danger">target</span>也就是一个目标文件，可以是Object File，也可以是执行文件。还可以是一个标签（Label），对于标签这种特性，在后续的“伪目标”章节中会有叙述。</p><p><span class="label danger">prerequisites</span>就是，要生成那个<span class="label danger">target</span>所需要的文件或是目标。</p><p><span class="label danger">command</span>也就是<span class="label danger">make</span>需要执行的命令。（任意的Shell命令）</p><p>这是一个文件的依赖关系，也就是说，<span class="label danger">target</span>这一个或多个的目标文件依赖于<span class="label danger">prerequisites</span>中的文件，其生成规则定义在<span class="label danger">command</span>中。说白一点就是说，<span class="label danger">prerequisites</span>中如果有一个以上的文件比<span class="label danger">target</span>文件要新的话，<span class="label danger">command</span>所定义的命令就会被执行。这就是<span class="label danger">Makefile</span>的规则。也就是<span class="label danger">Makefile</span>中最核心的内容。</p><p>说到底，<span class="label danger">Makefile</span>的东西就是这样一点，好像我的这篇文档也该结束了。呵呵。还不尽然，这是<span class="label danger">Makefile</span>的主线和核心，但要写好一个<span class="label danger">Makefile</span>还不够，我会以后面一点一点地结合我的工作经验给你慢慢到来。内容还多着呢。：）</p></blockquote><blockquote><p>【注】：在看别人写的<span class="label danger">Makefile</span>文件时，你可能会碰到以下三个变量：$@，$^，$&lt;代表的意义分别是：<br>他们三个是十分重要的三个变量，所代表的含义分别是：</p><ul><li>$@ — 目标文件，</li><li>$^ — 所有的依赖文件，</li><li>$&lt; — 第一个依赖文件。</li></ul></blockquote><h3 id="1-2-一个示例"><a href="#1-2-一个示例" class="headerlink" title="1.2 一个示例"></a>1.2 一个示例</h3><p>正如前面所说的，如果一个工程有3个头文件，和8个C文件，我们为了完成前面所述的那三个规则，我们的Makefile应该是下面的这个样子的。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">  cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">  cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">  cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">  cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">  cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">  cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">  cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">  cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">  cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">  rm edit main.o kbd.o command.o display.o \</span><br><span class="line">insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></p><p>反斜杠（\）是换行符的意思。这样比较便于Makefile的易读。我们可以把这个内容保存在文件为“Makefile”或“makefile”的文件中，然后在该目录下直接输入命令“make”就可以生成执行文件edit。如果要删除执行文件和所有的中间目标文件，那么，只要简单地执行一下“make clean”就可以了。</p><p>在这个makefile中，目标文件（target）包含：执行文件edit和中间目标文件（*.o），依赖文件（prerequisites）就是冒号后面的那些 .c 文件和 .h文件。每一个 .o 文件都有一组依赖文件，而这些 .o 文件又是执行文件 edit 的依赖文件。依赖关系的实质上就是说明了目标文件是由哪些文件生成的，换言之，目标文件是哪些文件更新的。</p><p>在定义好依赖关系后，后续的那一行定义了如何生成目标文件的操作系统命令，一定要以一个 <strong>Tab键作为开头</strong> 。记住，make并不管命令是怎么工作的，他只管执行所定义的命令。make会比较targets文件和prerequisites文件的修改日期，如果prerequisites文件的日期要比targets文件的日期要新，或者target不存在的话，那么，make就会执行后续定义的命令。</p><p>这里要说明一点的是，clean不是一个文件，它只不过是一个动作名字，有点像C语言中的lable一样，其冒号后什么也没有，那么，make就不会自动去找文件的依赖性，也就不会自动执行其后所定义的命令。要执行其后的命令，就要在make命令后明显得指出这个lable的名字。这样的方法非常有用，我们可以在一个makefile中定义不用的编译或是和编译无关的命令，比如程序的打包，程序的备份，等等。</p><h3 id="1-3-make是如何工作的"><a href="#1-3-make是如何工作的" class="headerlink" title="1.3 make是如何工作的"></a>1.3 make是如何工作的</h3><p>在默认的方式下，也就是我们只输入make命令。那么，</p><ol><li>make会在当前目录下找名字叫“Makefile”或“makefile”的文件。</li><li>如果找到，它会找文件中的第一个目标文件（target），在上面的例子中，他会找到“edit”这个文件，并把这个文件作为最终的目标文件。</li><li>如果edit文件不存在，或是edit所依赖的后面的 .o 文件的文件修改时间要比edit这个文件新，那么，他就会执行后面所定义的命令来生成edit这个文件。</li><li>如果edit所依赖的.o文件也存在，那么make会在当前文件中找目标为.o文件的依赖性，如果找到则再根据那一个规则生成.o文件。（这有点像一个堆栈的过程）</li><li>当然，你的C文件和H文件是存在的啦，于是make会生成 .o 文件，然后再用 .o 文件声明make的终极任务，也就是执行文件edit了。</li></ol><p>这就是整个make的依赖性，make会一层又一层地去找文件的依赖关系，直到最终编译出第一个目标文件。在找寻的过程中，如果出现错误，比如最后被依赖的文件找不到，那么make就会直接退出，并报错，而对于所定义的命令的错误，或是编译不成功，make根本不理。make只管文件的依赖性，即，如果在我找了依赖关系之后，冒号后面的文件还是不在，那么对不起，我就不工作啦。</p><p>通过上述分析，我们知道，像clean这种，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，我们可以显示要make执行。即命令——“make clean”，以此来清除所有的目标文件，以便重编译。</p><p>于是在我们编程中，如果这个工程已被编译过了，当我们修改了其中一个源文件，比如file.c，那么根据我们的依赖性，我们的目标file.o会被重编译（也就是在这个依性关系后面所定义的命令），于是file.o的文件也是最新的啦，于是file.o的文件修改时间要比edit要新，所以edit也会被重新链接了（详见edit目标文件后定义的命令）。</p><p>而如果我们改变了“command.h”，那么，kdb.o、command.o和files.o都会被重编译，并且，edit会被重链接。</p><h3 id="1-4-makefile中使用变量"><a href="#1-4-makefile中使用变量" class="headerlink" title="1.4 makefile中使用变量"></a>1.4 makefile中使用变量</h3><p>在上面的例子中，先让我们看看edit的规则：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">edit : main.o kbd.o command.o display.o \</span><br><span class="line">           insert.o search.o files.o utils.o</span><br><span class="line">     cc -o edit main.o kbd.o command.o display.o \</span><br><span class="line">                insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure></p><p>我们可以看到[.o]文件的字符串被重复了两次，如果我们的工程需要加入一个新的[.o]文件，那么我们需要在两个地方加（应该是三个地方，还有一个地方在clean中）。当然，我们的makefile并不复杂，所以在两个地方加也不累，但如果makefile变得复杂，那么我们就有可能会忘掉一个需要加入的地方，而导致编译失败。所以，为了makefile的易维护，在makefile中我们可以使用变量。makefile的变量也就是一个字符串，理解成C语言中的宏可能会更好。</p><p>比如，我们声明一个变量，叫objects, OBJECTS, objs, OBJS, obj, 或是 OBJ，反正不管什么啦，只要能够表示obj文件就行了。我们在makefile一开始就这样定义：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">         insert.o search.o files.o utils.o</span><br></pre></td></tr></table></figure><p>于是，我们就可以很方便地在我们的makefile中以“$(objects)”的方式来使用这个变量了，于是我们的改良版makefile就变成下面这个样子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">         insert.osearch.o files.o utils.o </span><br><span class="line">edit : $(objects)</span><br><span class="line">       cc -o edit $(objects)</span><br><span class="line">main.o : main.c defs.h</span><br><span class="line">       cc -c main.c</span><br><span class="line">kbd.o : kbd.c defs.h command.h</span><br><span class="line">       cc -c kbd.c</span><br><span class="line">command.o : command.c defs.h command.h</span><br><span class="line">       cc -c command.c</span><br><span class="line">display.o : display.c defs.h buffer.h</span><br><span class="line">       cc -c display.c</span><br><span class="line">insert.o : insert.c defs.h buffer.h</span><br><span class="line">       cc -c insert.c</span><br><span class="line">search.o : search.c defs.h buffer.h</span><br><span class="line">       cc -c search.c</span><br><span class="line">files.o : files.c defs.h buffer.h command.h</span><br><span class="line">       cc -c files.c</span><br><span class="line">utils.o : utils.c defs.h</span><br><span class="line">       cc -c utils.c</span><br><span class="line">clean :</span><br><span class="line">       rm edit $(objects)</span><br></pre></td></tr></table></figure><p>于是如果有新的 .o 文件加入，我们只需简单地修改一下 objects 变量就可以了。</p><p>关于变量更多的话题，我会在后续给你一一道来。</p><h3 id="1-5-让make自动推导"><a href="#1-5-让make自动推导" class="headerlink" title="1.5 让make自动推导"></a>1.5 让make自动推导</h3><p>GNU的make很强大，它可以自动推导文件以及文件依赖关系后面的命令，于是我们就没必要去在每一个[.o]文件后都写上类似的命令，因为，我们的make会自动识别，并自己推导命令。</p><p>只要make看到一个[.o]文件，它就会自动的把[.c]文件加在依赖关系中，如果make找到一个whatever.o，那么whatever.c，就会是whatever.o的依赖文件。并且 cc -c whatever.c 也会被推导出来，于是，我们的makefile再也不用写得这么复杂。我们的是新的makefile又出炉了。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">         insert.o search.o files.o utils.o</span><br><span class="line">edit : $(objects)</span><br><span class="line">       cc -o edit $(objects)</span><br><span class="line">main.o : defs.h</span><br><span class="line">kbd.o : defs.h command.h</span><br><span class="line">command.o : defs.h command.h</span><br><span class="line">display.o : defs.h buffer.h</span><br><span class="line">insert.o : defs.h buffer.h</span><br><span class="line">search.o : defs.h buffer.h</span><br><span class="line">files.o : defs.h buffer.h command.h</span><br><span class="line">utils.o : defs.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">       rm edit $(objects)</span><br></pre></td></tr></table></figure><p>这种方法，也就是make的“隐晦规则”。上面文件内容中，“.PHONY”表示，clean是个伪目标文件。</p><p>关于更为详细的“隐晦规则”和“伪目标文件”，我会在后续给你一一道来。</p><h3 id="1-6-另类风格的makefile"><a href="#1-6-另类风格的makefile" class="headerlink" title="1.6 另类风格的makefile"></a>1.6 另类风格的makefile</h3><p>即然我们的make可以自动推导命令，那么我看到那堆[.o]和[.h]的依赖就有点不爽，那么多的重复的[.h]，能不能把其收拢起来，好吧，没有问题，这个对于make来说很容易，谁叫它提供了自动推导命令和文件的功能呢？来看看最新风格的makefile吧。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">objects = main.o kbd.o command.o display.o \</span><br><span class="line">         insert.o search.o files.o utils.o</span><br><span class="line"></span><br><span class="line">edit : $(objects)</span><br><span class="line">       cc -o edit $(objects)</span><br><span class="line"></span><br><span class="line">$(objects) : defs.h</span><br><span class="line">kbd.o command.o files.o : command.h</span><br><span class="line">display.o insert.o search.o files.o : buffer.h</span><br><span class="line"></span><br><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">       rm edit $(objects)</span><br></pre></td></tr></table></figure><p>这种风格，让我们的makefile变得很简单，但我们的文件依赖关系就显得有点凌乱了。鱼和熊掌不可兼得。还看你的喜好了。我是不喜欢这种风格的，一是文件的依赖关系看不清楚，二是如果文件一多，要加入几个新的.o文件，那就理不清楚了。</p><h3 id="1-7-清空目标文件的规则"><a href="#1-7-清空目标文件的规则" class="headerlink" title="1.7 清空目标文件的规则"></a>1.7 清空目标文件的规则</h3><p>每个Makefile中都应该写一个清空目标文件（.o和执行文件）的规则，这不仅便于重编译，也很利于保持文件的清洁。这是一个“修养”（呵呵，还记得我的《编程修养》吗）。一般的风格都是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">clean:</span><br><span class="line">    rm edit $(objects)</span><br></pre></td></tr></table></figure><p>更为稳健的做法是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY : clean</span><br><span class="line">clean :</span><br><span class="line">    -rm edit $(objects)</span><br></pre></td></tr></table></figure><p>前面说过，.PHONY意思表示clean是一个“伪目标”，。而在rm命令前面加了一个小减号的意思就是，也许某些文件出现问题，但不要管，继续做后面的事。当然，clean的规则不要放在文件的开头，不然，这就会变成make的默认目标，相信谁也不愿意这样。不成文的规矩是——“clean从来都是放在文件的最后”。</p><p>上面就是一个makefile的概貌，也是makefile的基础，下面还有很多makefile的相关细节，准备好了吗？准备好了就来。</p><h2 id="MakeFile系列"><a href="#MakeFile系列" class="headerlink" title="MakeFile系列"></a>MakeFile系列</h2><ul><li><a href="/2020/11/12/cpp/cpp-makefile-0/" title="学习MakeFile-前言">学习MakeFile-前言</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-1/" title="学习MakeFile-介绍">学习MakeFile-介绍</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-2/" title="学习MakeFile-总述">学习MakeFile-总述</a>  </li><li><a href="/2020/10/17/cpp/cpp-makefile-3/" title="学习MakeFile-书写规则">学习MakeFile-书写规则</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-simple/" title="学习MakeFile-渐进式">学习MakeFile-渐进式</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;引子&quot;&gt;&lt;a href=&quot;#引子&quot; class=&quot;headerlink&quot; title=&quot;引子&quot;&gt;&lt;/a&gt;引子&lt;/h2&gt;&lt;p&gt;为了让逐个编译的过程变成一条命令&lt;/p&gt;
&lt;h2 id=&quot;1、Makefile-介绍&quot;&gt;&lt;a href=&quot;#1、Makefile-介绍&quot; class=&quot;headerlink&quot; title=&quot;1、Makefile 介绍&quot;&gt;&lt;/a&gt;1、Makefile 介绍&lt;/h2&gt;&lt;p&gt;make命令执行时，需要一个 Makefile 文件，以告诉make命令需要怎么样的去编译和链接程序。&lt;/p&gt;
&lt;p&gt;首先，我们用一个示例来说明Makefile的书写规则。以便给大家一个感性认识。这个示例来源于GNU的make使用手册，在这个示例中，我们的工程有8个C文件，和3个头文件，我们要写一个Makefile来告诉make命令如何编译和链接这几个文件。我们的规则是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;如果这个工程没有编译过，那么我们的所有C文件都要编译并被链接。&lt;/li&gt;
&lt;li&gt;如果这个工程的某几个C文件被修改，那么我们只编译被修改的C文件，并链接目标程序。&lt;/li&gt;
&lt;li&gt;如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的C文件，并链接目标程序。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;只要我们的Makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自己编译所需要的文件和链接目标程序。&lt;/p&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>学习MakeFile</title>
    <link href="http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-simple/"/>
    <id>http://blog.rcant.com/2020/11/12/cpp/cpp-makefile-simple/</id>
    <published>2020-11-12T03:39:17.000Z</published>
    <updated>2023-01-06T09:30:03.392Z</updated>
    
    <content type="html"><![CDATA[<p>Makefile其实不难学，对于一些基本概念百度上应该很多，这里分享一个循序渐进的学习方式，保证让你快速掌握Makefile的编写。本文首发于公众号：良许Linux，里面有一个 Makefile 系列，欢迎关注交流！</p><h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1. 前言"></a>1. 前言</h2><p>通过之前章节的学习，我们对Makefile有个基础的认识，现在开始自己动手写Makefile。目前网络上有不少可以自动生成Makefile的工具，但很多项目其实没必要那么复杂，完全可以自己动手写出来。而且对于初学者来说，自己动手写一遍Makefile可以顶看十遍高手写的Makefile，也可以加深对Makefile的理解，将来公司的Makefile有需要修改的时候自己就可以动手搞定，不需要依靠他人，何乐而不为？</p><h2 id="2-源代码"><a href="#2-源代码" class="headerlink" title="2. 源代码"></a>2. 源代码</h2><p>介绍在本教程中用于示例的代码很简单，仅仅是在main函数中调用了fun1及fun2函数，而fun1及fun2独立写在fun1.c及fun2.c里。代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">//main.c  </span><br><span class="line">int main()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;hello world\n&quot;);  </span><br><span class="line">    fun1();  </span><br><span class="line">    fun2();  </span><br><span class="line">&#125;  </span><br><span class="line"></span><br><span class="line">//fun1.c  </span><br><span class="line">void fun1()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;this is fun1\n&quot;);  </span><br><span class="line">&#125;  </span><br><span class="line">//fun2.c  </span><br><span class="line">void fun2()  </span><br><span class="line">&#123;  </span><br><span class="line">    printf(&quot;this is fun2\n&quot;);  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><span id="more"></span><h2 id="3-第一版Makefile"><a href="#3-第一版Makefile" class="headerlink" title="3. 第一版Makefile"></a>3. 第一版Makefile</h2><p>对于我们的示例代码，不通过Makefile编译其实也很简单：gcc main.c fun1.c fun2.c -o app  我们知道，Makefile其实就是按规则一条条的执行。所以，我们完全可以把上面那条命令写成Makefile的一个规则。我们的目标是app，按此写法依赖是main.c fun1.c fun2.c，则最终的Makefile如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">app: main.c fun1.c fun2.c  </span><br><span class="line">    gcc main.c fun1.c fun2.c -o app</span><br></pre></td></tr></table></figure><br>但这个版本的Makefile有两个很重要的不足：</p><ol><li>对于简单代码还好，而对于大型项目，具有成千上万代码来说，仅用一行规则是完全不够的，即使够的话也需要写很长的一条规则；</li><li>任何文件只要稍微做了修改就需要整个项目完整的重要编译。</li></ol><p>基于此，我们在第一版的基础上优化出第二版。</p><h2 id="4-第二版Makefile"><a href="#4-第二版Makefile" class="headerlink" title="4. 第二版Makefile"></a>4. 第二版Makefile</h2><p>在第二版Makefile中，为了避免改动任何代码就需要重新编译整个项目的问题，我们将主规则的各个依赖替换成各自的中间文件，即main.c —&gt; main.o，fun1.c —&gt; fun1.o，fun2.c —&gt; fun2.o，再对每个中间文件的生成各自写条规则比如对于main.o，规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">main.o: main.c  </span><br><span class="line">    gcc -c main.c -o main.o  </span><br></pre></td></tr></table></figure><p>这样做的好处是，当有一个文件发生改动时，只需重新编译此文件即可，而无需重新编译整个项目。完整Makefile如下：<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">app: main.o fun1.o fun2.o  </span><br><span class="line">    gcc main.o fun1.o fun2.o -o app  </span><br><span class="line">​</span><br><span class="line">main.o: main.c  </span><br><span class="line">    gcc -c main.c -o main.o  </span><br><span class="line">​</span><br><span class="line">fun1.o: fun1.c  </span><br><span class="line">    gcc -c fun1.c -o fun1.o  </span><br><span class="line">​</span><br><span class="line">fun2.o: fun2.c  </span><br><span class="line">    gcc -c fun2.c -o fun2.o  </span><br></pre></td></tr></table></figure><br>第二版Makefile同样具有一些缺陷：</p><pre><code>1. 里面存在一些重复的内容，可以考虑用变量代替；2. 后面三条规则非常类似，可以考虑用一条模式规则代替。</code></pre><p>基于此，我们在第二版的基础上优化出第三版。</p><h2 id="5-第三版Makefile"><a href="#5-第三版Makefile" class="headerlink" title="5. 第三版Makefile"></a>5. 第三版Makefile</h2><p>在第三版Makefile中，我们使用变量及模式规则使Makefile更加简洁。使用的三个变量如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o fun1.o fun2.o  </span><br><span class="line">target = app  </span><br><span class="line">CC = gcc  </span><br></pre></td></tr></table></figure><p>使用的模式规则为：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">%.o: %.c  </span><br><span class="line">        $(CC) -c $&lt; -o $@  </span><br></pre></td></tr></table></figure><p>这条模式规则表示：所有的.o文件都由对应的.c文件生成。在规则里，我们又看到了两个自动变量：$&lt;和$@。其实自动变量有很多，常用的有三个：        </p><pre><code>- $&lt;：第一个依赖文件；        - $@：目标；        - $^：所有不重复的依赖文件，以空格分开</code></pre><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">obj = main.o fun1.o fun2.o  </span><br><span class="line">target = app  </span><br><span class="line">CC = gcc  </span><br><span class="line">​</span><br><span class="line">$(target): $(obj)  </span><br><span class="line">    $(CC) $(obj) -o $(target)  </span><br><span class="line">​</span><br><span class="line">%.o: %.c  </span><br><span class="line">    $(CC) -c $&lt; -o $@  </span><br></pre></td></tr></table></figure><p>第三版Makefile依然存在一些缺陷：</p><pre><code>1. obj对应的文件需要一个个输入，工作量大；2. 文件数目比较少时还好，文件数目一旦很多的话，obj将很长；3. 而且每增加/除一个文件，都需要修改Makefile。</code></pre><p>基于此，我们在第二版的基础上优化出第四版。</p><h2 id="6-第四版Makefile"><a href="#6-第四版Makefile" class="headerlink" title="6. 第四版Makefile"></a>6. 第四版Makefile</h2><p>在第四版Makefile中，我们隆重推出了两个函数：wildcard和patsubst。</p><h3 id="wildcard："><a href="#wildcard：" class="headerlink" title="wildcard："></a>wildcard：</h3><p>扩展通配符，搜索指定文件。在此我们使用src = $(wildcard ./*.c)，代表在当前目录下搜索所有的.c文件，并赋值给src。函数执行结束后，src的值为：main.c fun1.c fun2.c。</p><h3 id="patsubst："><a href="#patsubst：" class="headerlink" title="patsubst："></a>patsubst：</h3><p>替换通配符，按指定规则做替换。在此我们使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = $(patsubst %.c, %.o, $(src))</span><br></pre></td></tr></table></figure><p>代表将src里的每个文件都由.c替换成.o。函数执行结束后，obj的值为main.o fun1.o fun2.o，其实跟第三版Makefile的obj值一模一样，只不过在这里它更智能一些，也更灵活。除了使用patsubst函数外，我们也可以使用模式规则达到同样的效果，比如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">obj = $(src:%.c=%.o)</span><br></pre></td></tr></table></figure><p>也是代表将src里的每个文件都由.c替换成.o。几乎每个Makefile里都会有一个伪目标clean，这样我们通过执行make clean命令就是将中间文件如.o文件及目标文件全部删除，留下干净的空间。一般是如下写法：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.PHONY: clean  </span><br><span class="line">clean:  </span><br><span class="line">    rm -rf $(obj) $(target)  </span><br></pre></td></tr></table></figure><p>.PHONY代表声明clean是一个伪目标，这样每次执行make clean时，下面的规则都会被执行。<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">src = $(wildcard ./*.c)  </span><br><span class="line">obj = $(patsubst %.c, %.o, $(src))  </span><br><span class="line">#obj = $(src:%.c=%.o)  </span><br><span class="line">target = app  </span><br><span class="line">CC = gcc  </span><br><span class="line">​</span><br><span class="line">$(target): $(obj)  </span><br><span class="line">    $(CC) $(obj) -o $(target)  </span><br><span class="line">​</span><br><span class="line">%.o: %.c  </span><br><span class="line">    $(CC) -c $&lt; -o $@  </span><br><span class="line">​</span><br><span class="line">.PHONY: clean  </span><br><span class="line">clean:  </span><br><span class="line">    rm -rf $(obj) $(target) </span><br></pre></td></tr></table></figure></p><h2 id="7-总结"><a href="#7-总结" class="headerlink" title="7. 总结"></a>7. 总结</h2><p>Makefile其实也并不难，但关键的是一定要自己动手写，这样才会更加加深理解，否则也容易造成眼高手低。如果实在不知道从何下手，可以尝试按上面的教程，一步步写下来，也只需要写四个版本而已，写完了相信就有了初步的理解。我是良许，世界500强外企 Linux 开发工程师，专业生产 Linux 方面干货，欢迎点赞、收藏！</p><p>作者：程序员良许<br>链接：<a href="https://www.zhihu.com/question/23792247/answer/600773044">https://www.zhihu.com/question/23792247/answer/600773044</a><br>来源：知乎<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p><h2 id="MakeFile系列"><a href="#MakeFile系列" class="headerlink" title="MakeFile系列"></a>MakeFile系列</h2><ul><li><a href="/2020/11/12/cpp/cpp-makefile-0/" title="学习MakeFile-前言">学习MakeFile-前言</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-1/" title="学习MakeFile-介绍">学习MakeFile-介绍</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-2/" title="学习MakeFile-总述">学习MakeFile-总述</a>  </li><li><a href="/2020/10/17/cpp/cpp-makefile-3/" title="学习MakeFile-书写规则">学习MakeFile-书写规则</a>  </li><li><a href="/2020/11/12/cpp/cpp-makefile-simple/" title="学习MakeFile-渐进式">学习MakeFile-渐进式</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;Makefile其实不难学，对于一些基本概念百度上应该很多，这里分享一个循序渐进的学习方式，保证让你快速掌握Makefile的编写。本文首发于公众号：良许Linux，里面有一个 Makefile 系列，欢迎关注交流！&lt;/p&gt;
&lt;h2 id=&quot;1-前言&quot;&gt;&lt;a href=&quot;#1-前言&quot; class=&quot;headerlink&quot; title=&quot;1. 前言&quot;&gt;&lt;/a&gt;1. 前言&lt;/h2&gt;&lt;p&gt;通过之前章节的学习，我们对Makefile有个基础的认识，现在开始自己动手写Makefile。目前网络上有不少可以自动生成Makefile的工具，但很多项目其实没必要那么复杂，完全可以自己动手写出来。而且对于初学者来说，自己动手写一遍Makefile可以顶看十遍高手写的Makefile，也可以加深对Makefile的理解，将来公司的Makefile有需要修改的时候自己就可以动手搞定，不需要依靠他人，何乐而不为？&lt;/p&gt;
&lt;h2 id=&quot;2-源代码&quot;&gt;&lt;a href=&quot;#2-源代码&quot; class=&quot;headerlink&quot; title=&quot;2. 源代码&quot;&gt;&lt;/a&gt;2. 源代码&lt;/h2&gt;&lt;p&gt;介绍在本教程中用于示例的代码很简单，仅仅是在main函数中调用了fun1及fun2函数，而fun1及fun2独立写在fun1.c及fun2.c里。代码如下：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;//main.c  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;int main()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;hello world\n&amp;quot;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun1();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    fun2();  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//fun1.c  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void fun1()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;this is fun1\n&amp;quot;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;//fun2.c  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;void fun2()  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    printf(&amp;quot;this is fun2\n&amp;quot;);  &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="C" scheme="http://blog.rcant.com/categories/C/"/>
    
    
    <category term="c" scheme="http://blog.rcant.com/tags/c/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 发布者确认</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-publish-confirm/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-publish-confirm/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:25.889Z</updated>
    
    <content type="html"><![CDATA[<p>发布者确认</p><h2 id="发布者确认"><a href="#发布者确认" class="headerlink" title="发布者确认"></a>发布者确认</h2><p>发布者确认是RabbitMQ的扩展，可以实现可靠的发布。在channel上启用发布者确认后，代理将异步确认客户端发布的消息，这意味着他们已在服务器端处理。</p><h2 id="在频道上启用发布者确认"><a href="#在频道上启用发布者确认" class="headerlink" title="在频道上启用发布者确认"></a>在频道上启用发布者确认</h2><p>发布者确认是AMQP 0.9.1协议的RabbitMQ扩展，因此默认情况下未启用它们。发布者确认是通过ConfirmSelect方法在通道级别启用的：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var channel = connection.CreateModel();</span><br><span class="line">channel.ConfirmSelect();</span><br></pre></td></tr></table></figure><p>必须在希望使用发布者确认的每个频道上调用此方法。确认仅应启用一次，而不是对每个已发布的消息都启用</p><h3 id="策略1：Publishing-Messages-Individually"><a href="#策略1：Publishing-Messages-Individually" class="headerlink" title="策略1：Publishing Messages Individually"></a>策略1：Publishing Messages Individually</h3><p>每条消息发步后,等待确认<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">private static void PublishMessagesIndividually()</span><br><span class="line">&#123;</span><br><span class="line">    using (var connection = CreateConnection())</span><br><span class="line">    using (var channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">        channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">        var timer = new Stopwatch();</span><br><span class="line">        timer.Start();</span><br><span class="line">        for (int i = 0; i &lt; MESSAGE_COUNT; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var body = Encoding.UTF8.GetBytes(i.ToString());</span><br><span class="line">            channel.BasicPublish(exchange: &quot;&quot;, routingKey: queueName, basicProperties: null, body: body);</span><br><span class="line">            channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line">        &#125;</span><br><span class="line">        timer.Stop();</span><br><span class="line">        Console.WriteLine($&quot;Published &#123;MESSAGE_COUNT:N0&#125; messages individually in &#123;timer.ElapsedMilliseconds:N0&#125; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>在前面的示例中，我们像往常一样发布一条消息，并等待通过Channel＃WaitForConfirmsOrDie(TimeSpan)方法进行确认。确认消息后，该方法立即返回。如果未在超时时间内确认该消息或该消息没有被确认(这意味着代理出于某种原因无法处理该消息)，则该方法将引发异常。异常的处理通常包括记录错误消息和/或重试发送消息。</p><p>此方法非常简单，但也有一个主要缺点：由于消息的确认会阻止所有后续消息的发布，因此它会大大降低发布速度。这种方法不会提供每秒超过数百条已发布消息的吞吐量。但是，对于某些应用程序来说这可能已经足够了。</p><p>发布者确认异步吗？</p><p>我们在一开始提到代理程序以异步方式确认发布的消息，但是在第一个示例中，代码同步等待直到消息被确认。<br>客户端实际上异步接收确认，并相应地取消阻止对WaitForConfirmsOrDie的调用 。将WaitForConfirmsOrDie视为依赖于后台异步通知的同步。</p><span id="more"></span><h3 id="策略2：批量发布消息"><a href="#策略2：批量发布消息" class="headerlink" title="策略2：批量发布消息"></a>策略2：批量发布消息</h3><p>为了改进前面的示例，我们可以发布一批消息，并等待整个批次被确认。以下示例使用了100个批次：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">private static void PublishMessagesInBatch()</span><br><span class="line">&#123;</span><br><span class="line">    using (var connection = CreateConnection())</span><br><span class="line">    using (var channel = connection.CreateModel())</span><br><span class="line">    &#123;</span><br><span class="line">        var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">        channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">        var batchSize = 100;</span><br><span class="line">        var outstandingMessageCount = 0;</span><br><span class="line">        var timer = new Stopwatch();</span><br><span class="line">        timer.Start();</span><br><span class="line">        for (int i = 0; i &lt; MESSAGE_COUNT; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            var body = Encoding.UTF8.GetBytes(i.ToString());</span><br><span class="line">            channel.BasicPublish(exchange: &quot;&quot;, routingKey: queueName, basicProperties: null, body: body);</span><br><span class="line">            outstandingMessageCount++;</span><br><span class="line"></span><br><span class="line">            if (outstandingMessageCount == batchSize)</span><br><span class="line">            &#123;</span><br><span class="line">                channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line">                outstandingMessageCount = 0;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        if (outstandingMessageCount &gt; 0)</span><br><span class="line">            channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line"></span><br><span class="line">        timer.Stop();</span><br><span class="line">        Console.WriteLine($&quot;Published &#123;MESSAGE_COUNT:N0&#125; messages in batch in &#123;timer.ElapsedMilliseconds:N0&#125; ms&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>与等待确认单个消息相比，等待一批消息被确认可以极大地提高吞吐量（对于远程RabbitMQ节点，这最多可以达到20-30倍）。<br>缺点之一是我们不知道发生故障时到底出了什么问题，因此我们可能必须将整个批处理保存在内存中，以记录有意义的内容或重新发布消息。而且该解决方案仍然是同步的，因此它阻止了消息的发布。</p><h3 id="策略3：处理发布者异步确认"><a href="#策略3：处理发布者异步确认" class="headerlink" title="策略3：处理发布者异步确认"></a>策略3：处理发布者异步确认</h3><p>代理异步确认已发布的消息，只需在客户端上注册一个回调即可收到这些确认的通知：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var channel = connection.CreateModel();</span><br><span class="line">channel.ConfirmSelect();</span><br><span class="line">channel.BasicAcks += (sender, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  // RabbitMQ 确认的消息</span><br><span class="line">&#125;;</span><br><span class="line">channel.BasicNacks += (sender, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">  // RabbitMQ 未确认的消息(可以认为是丢失的消息)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>有2个回调：一个用于确认的消息，另一个用于未确认的消息（代理可以认为丢失的消息）。这两个回调都有一个对应的 <strong>EventArgs</strong> 参数（ea），其中包含：</p><ul><li>DeliveryTag : 标识 <strong>已确认或丢失</strong> 消息的序列号。</li><li>multiple : 这是一个布尔值。如果为false，则仅 <strong>确认/丢失</strong> 一条消息；如果为true，则将 <strong>确认/丢失</strong> 序列号较低或相等的所有消息。</li></ul><p>可以在消息发布之前通过 <strong>Channel＃NextPublishSeqNo</strong> 获取序列号</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var sequenceNumber = channel.NextPublishSeqNo;</span><br><span class="line">channel.BasicPublish(exchange, queue, properties, body);</span><br></pre></td></tr></table></figure><p>将消息与序列号关联的一种简单方法是使用字典。假设我们要发布字符串，因为它们很容易变成要发布的字节数组。这是一个代码示例，该示例使用字典将发布序列号与消息的字符串主体相关联：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var outstandingConfirms = new ConcurrentDictionary&lt;ulong, string&gt;();</span><br><span class="line">// ... code for confirm callbacks will come later</span><br><span class="line">var body = &quot;...&quot;;</span><br><span class="line">outstandingConfirms.TryAdd(channel.NextPublishSeqNo, body);</span><br><span class="line">channel.BasicPublish(exchange, queue, properties, Encoding.UTF8.GetBytes(body));</span><br></pre></td></tr></table></figure><p>现在，发布消息 使用字典来跟踪 消息是否被确认。<br>我们需要在消息确认回调时清理此字典，并做一些类似在消息丢失警告的操作：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var outstandingConfirms = new ConcurrentDictionary&lt;ulong, string&gt;();</span><br><span class="line"></span><br><span class="line">void ​cleanOutstandingConfirms(ulong sequenceNumber, bool multiple)</span><br><span class="line">&#123;</span><br><span class="line">   ​if (multiple)</span><br><span class="line">   ​&#123;</span><br><span class="line">       ​var confirmed = outstandingConfirms.Where(k =&gt; k.Key &lt;= sequenceNumber);</span><br><span class="line">       ​foreach (var entry in confirmed)</span><br><span class="line">       ​&#123;</span><br><span class="line">           ​outstandingConfirms.TryRemove(entry.Key, out _);</span><br><span class="line">       ​&#125;</span><br><span class="line">   ​&#125;</span><br><span class="line">   ​else</span><br><span class="line">   ​&#123;</span><br><span class="line">       ​outstandingConfirms.TryRemove(sequenceNumber, out _);</span><br><span class="line">   ​&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">channel.BasicAcks += (sender, ea) =&gt; cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);</span><br><span class="line">channel.BasicNacks += (sender, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">   ​outstandingConfirms.TryGetValue(ea.DeliveryTag, out string body);</span><br><span class="line">   ​Console.WriteLine($&quot;Message with body &#123;body&#125; has been nack-ed. Sequence number: &#123;ea.DeliveryTag&#125;, multiple: &#123;ea.Multiple&#125;&quot;);</span><br><span class="line">   ​cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);</span><br><span class="line">&#125;;</span><br><span class="line">// ... publishing code</span><br></pre></td></tr></table></figure><h3 id="所有代码"><a href="#所有代码" class="headerlink" title="所有代码"></a>所有代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Concurrent;</span><br><span class="line">using System.Diagnostics;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">class PublisherConfirms</span><br><span class="line">&#123;</span><br><span class="line">    private const int MESSAGE_COUNT = 50_000;</span><br><span class="line"></span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        PublishMessagesIndividually();</span><br><span class="line">        PublishMessagesInBatch();</span><br><span class="line">        HandlePublishConfirmsAsynchronously();</span><br><span class="line">        Console.ReadLine();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static IConnection CreateConnection()</span><br><span class="line">    &#123;</span><br><span class="line">        var factory = new ConnectionFactory &#123; HostName = &quot;localhost&quot;, VirtualHost = &quot;frexport&quot; &#125;;</span><br><span class="line">        return factory.CreateConnection();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void PublishMessagesIndividually()</span><br><span class="line">    &#123;</span><br><span class="line">        using (var connection = CreateConnection())</span><br><span class="line">        using (var channel = connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">            channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">            var timer = new Stopwatch();</span><br><span class="line">            timer.Start();</span><br><span class="line">            for (int i = 0; i &lt; MESSAGE_COUNT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var body = Encoding.UTF8.GetBytes(i.ToString());</span><br><span class="line">                channel.BasicPublish(exchange: &quot;&quot;, routingKey: queueName, basicProperties: null, body: body);</span><br><span class="line">                channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line">            &#125;</span><br><span class="line">            timer.Stop();</span><br><span class="line">            Console.WriteLine($&quot;Published &#123;MESSAGE_COUNT:N0&#125; messages individually in &#123;timer.ElapsedMilliseconds:N0&#125; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void PublishMessagesInBatch()</span><br><span class="line">    &#123;</span><br><span class="line">        using (var connection = CreateConnection())</span><br><span class="line">        using (var channel = connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">            channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">            var batchSize = 100;</span><br><span class="line">            var outstandingMessageCount = 0;</span><br><span class="line">            var timer = new Stopwatch();</span><br><span class="line">            timer.Start();</span><br><span class="line">            for (int i = 0; i &lt; MESSAGE_COUNT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var body = Encoding.UTF8.GetBytes(i.ToString());</span><br><span class="line">                channel.BasicPublish(exchange: &quot;&quot;, routingKey: queueName, basicProperties: null, body: body);</span><br><span class="line">                outstandingMessageCount++;</span><br><span class="line"></span><br><span class="line">                if (outstandingMessageCount == batchSize)</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line">                    outstandingMessageCount = 0;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (outstandingMessageCount &gt; 0)</span><br><span class="line">                channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));</span><br><span class="line"></span><br><span class="line">            timer.Stop();</span><br><span class="line">            Console.WriteLine($&quot;Published &#123;MESSAGE_COUNT:N0&#125; messages in batch in &#123;timer.ElapsedMilliseconds:N0&#125; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static void HandlePublishConfirmsAsynchronously()</span><br><span class="line">    &#123;</span><br><span class="line">        using (var connection = CreateConnection())</span><br><span class="line">        using (var channel = connection.CreateModel())</span><br><span class="line">        &#123;</span><br><span class="line">            var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line">            channel.ConfirmSelect();</span><br><span class="line"></span><br><span class="line">            var outstandingConfirms = new ConcurrentDictionary&lt;ulong, string&gt;();</span><br><span class="line"></span><br><span class="line">            void cleanOutstandingConfirms(ulong sequenceNumber, bool multiple)</span><br><span class="line">            &#123;</span><br><span class="line">                if (multiple)</span><br><span class="line">                &#123;</span><br><span class="line">                    var confirmed = outstandingConfirms.Where(k =&gt; k.Key &lt;= sequenceNumber);</span><br><span class="line">                    foreach (var entry in confirmed)</span><br><span class="line">                        outstandingConfirms.TryRemove(entry.Key, out _);</span><br><span class="line">                &#125;</span><br><span class="line">                else</span><br><span class="line">                    outstandingConfirms.TryRemove(sequenceNumber, out _);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            channel.BasicAcks += (sender, ea) =&gt; cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);</span><br><span class="line">            channel.BasicNacks += (sender, ea) =&gt;</span><br><span class="line">            &#123;</span><br><span class="line">                outstandingConfirms.TryGetValue(ea.DeliveryTag, out string body);</span><br><span class="line">                Console.WriteLine($&quot;Message with body &#123;body&#125; has been nack-ed. Sequence number: &#123;ea.DeliveryTag&#125;, multiple: &#123;ea.Multiple&#125;&quot;);</span><br><span class="line">                cleanOutstandingConfirms(ea.DeliveryTag, ea.Multiple);</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            var timer = new Stopwatch();</span><br><span class="line">            timer.Start();</span><br><span class="line">            for (int i = 0; i &lt; MESSAGE_COUNT; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                var body = i.ToString();</span><br><span class="line">                outstandingConfirms.TryAdd(channel.NextPublishSeqNo, i.ToString());</span><br><span class="line">                channel.BasicPublish(exchange: &quot;&quot;, routingKey: queueName, basicProperties: null, body: Encoding.UTF8.GetBytes(body));</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            if (!WaitUntil(60, () =&gt; outstandingConfirms.IsEmpty))</span><br><span class="line">                throw new Exception(&quot;All messages could not be confirmed in 60 seconds&quot;);</span><br><span class="line"></span><br><span class="line">            timer.Stop();</span><br><span class="line">            Console.WriteLine($&quot;Published &#123;MESSAGE_COUNT:N0&#125; messages and handled confirm asynchronously &#123;timer.ElapsedMilliseconds:N0&#125; ms&quot;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    private static bool WaitUntil(int numberOfSeconds, Func&lt;bool&gt; condition)</span><br><span class="line">    &#123;</span><br><span class="line">        int waited = 0;</span><br><span class="line">        while (!condition() &amp;&amp; waited &lt; numberOfSeconds * 1000)</span><br><span class="line">        &#123;</span><br><span class="line">            Thread.Sleep(100);</span><br><span class="line">            waited += 100;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        return condition();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ在本机运行的效果"><a href="#RabbitMQ在本机运行的效果" class="headerlink" title="RabbitMQ在本机运行的效果"></a>RabbitMQ在本机运行的效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Published 50,000 messages individually in 5,549 ms</span><br><span class="line">Published 50,000 messages in batch in 2,331 ms</span><br><span class="line">Published 50,000 messages and handled confirms asynchronously in 4,054 ms</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ在远程运行的效果"><a href="#RabbitMQ在远程运行的效果" class="headerlink" title="RabbitMQ在远程运行的效果"></a>RabbitMQ在远程运行的效果</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Published 50,000 messages individually in 231,541 ms</span><br><span class="line">Published 50,000 messages in batch in 7,232 ms</span><br><span class="line">Published 50,000 messages and handled confirms asynchronously in 6,332 ms</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;发布者确认&lt;/p&gt;
&lt;h2 id=&quot;发布者确认&quot;&gt;&lt;a href=&quot;#发布者确认&quot; class=&quot;headerlink&quot; title=&quot;发布者确认&quot;&gt;&lt;/a&gt;发布者确认&lt;/h2&gt;&lt;p&gt;发布者确认是RabbitMQ的扩展，可以实现可靠的发布。在channel上启用发布者确认后，代理将异步确认客户端发布的消息，这意味着他们已在服务器端处理。&lt;/p&gt;
&lt;h2 id=&quot;在频道上启用发布者确认&quot;&gt;&lt;a href=&quot;#在频道上启用发布者确认&quot; class=&quot;headerlink&quot; title=&quot;在频道上启用发布者确认&quot;&gt;&lt;/a&gt;在频道上启用发布者确认&lt;/h2&gt;&lt;p&gt;发布者确认是AMQP 0.9.1协议的RabbitMQ扩展，因此默认情况下未启用它们。发布者确认是通过ConfirmSelect方法在通道级别启用的：&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;var channel = connection.CreateModel();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;channel.ConfirmSelect();&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;必须在希望使用发布者确认的每个频道上调用此方法。确认仅应启用一次，而不是对每个已发布的消息都启用&lt;/p&gt;
&lt;h3 id=&quot;策略1：Publishing-Messages-Individually&quot;&gt;&lt;a href=&quot;#策略1：Publishing-Messages-Individually&quot; class=&quot;headerlink&quot; title=&quot;策略1：Publishing Messages Individually&quot;&gt;&lt;/a&gt;策略1：Publishing Messages Individually&lt;/h3&gt;&lt;p&gt;每条消息发步后,等待确认&lt;br&gt;&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;19&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;20&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;private static void PublishMessagesIndividually()&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    using (var connection = CreateConnection())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    using (var channel = connection.CreateModel())&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var queueName = channel.QueueDeclare().QueueName;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        channel.ConfirmSelect();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        var timer = new Stopwatch();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timer.Start();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        for (int i = 0; i &amp;lt; MESSAGE_COUNT; i++)&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#123;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            var body = Encoding.UTF8.GetBytes(i.ToString());&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            channel.BasicPublish(exchange: &amp;quot;&amp;quot;, routingKey: queueName, basicProperties: null, body: body);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;            channel.WaitForConfirmsOrDie(new TimeSpan(0, 0, 5));&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        timer.Stop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;        Console.WriteLine($&amp;quot;Published &amp;#123;MESSAGE_COUNT:N0&amp;#125; messages individually in &amp;#123;timer.ElapsedMilliseconds:N0&amp;#125; ms&amp;quot;);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &amp;#125;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&amp;#125;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
&lt;p&gt;在前面的示例中，我们像往常一样发布一条消息，并等待通过Channel＃WaitForConfirmsOrDie(TimeSpan)方法进行确认。确认消息后，该方法立即返回。如果未在超时时间内确认该消息或该消息没有被确认(这意味着代理出于某种原因无法处理该消息)，则该方法将引发异常。异常的处理通常包括记录错误消息和/或重试发送消息。&lt;/p&gt;
&lt;p&gt;此方法非常简单，但也有一个主要缺点：由于消息的确认会阻止所有后续消息的发布，因此它会大大降低发布速度。这种方法不会提供每秒超过数百条已发布消息的吞吐量。但是，对于某些应用程序来说这可能已经足够了。&lt;/p&gt;
&lt;p&gt;发布者确认异步吗？&lt;/p&gt;
&lt;p&gt;我们在一开始提到代理程序以异步方式确认发布的消息，但是在第一个示例中，代码同步等待直到消息被确认。&lt;br&gt;客户端实际上异步接收确认，并相应地取消阻止对WaitForConfirmsOrDie的调用 。将WaitForConfirmsOrDie视为依赖于后台异步通知的同步。&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 路由模式</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-routing/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-routing/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:31.698Z</updated>
    
    <content type="html"><![CDATA[<p>路由模式</p><h3 id="Routing-路由模式"><a href="#Routing-路由模式" class="headerlink" title="Routing 路由模式"></a>Routing 路由模式</h3><pre class="mermaid">graph LR;    id1([Product]);    id2([ExChange]);    id3([amq.gen-DjtYso1eaz52eM3mAJToaw])    id4([amq.gen-nLrD6gHpPBMY-oqM-tBVcQ])    id5([C1])    id6([C2])    style id1 fill:#0ff,stroke:#333;    style id2 fill:#33c,stroke:#333;    style id3 fill:#f00,stroke:#333;    style id4 fill:#f00,stroke:#333;    style id5 fill:#3cf,stroke:#333;    style id6 fill:#3cf,stroke:#333;    id1-->id2;    id2-->|error|id3;    id3-->id5;    id2-->|error|id4;    id2-->|info|id4;    id4-->id6;</pre><p>注意</p><ol><li>生产者发送消息到交换机，要指定路由Key</li><li>消费者将队列绑定到交换机时需要指定路由Key</li></ol><p>这个是一种 <strong>完全匹配</strong> 只有匹配到的消费者才能消费消息</p><p>消息中的路由键值如果和Binding中的binding key 一致，交换机就将消息发送到对应的队列中。<br>路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为”dog”,则只转发routingkey 标记为”dog”的消息,不会转发”dog.puppy”,也不会转发”dog.guard”等等。这个是时 <strong>完全匹配</strong>、单播的模式</p><span id="more"></span><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者:"></a>生产者:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line"></span><br><span class="line">namespace RoutingMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    class EmitLogDirect</span><br><span class="line">    &#123;</span><br><span class="line">        static string ExchangeName = &quot;direct_logs&quot;;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //指定交换机以及交换机模式</span><br><span class="line">                    channel.ExchangeDeclare(exchange: ExchangeName,</span><br><span class="line">                        type: ExchangeType.Direct,</span><br><span class="line">                        durable: true);</span><br><span class="line"></span><br><span class="line">                    var severity = (args.Length &gt; 0) ? args[0] : &quot;info&quot;;</span><br><span class="line">                    var message = (args.Length &gt; 1) ? args[1] : &quot;HelloWorld!&quot;;</span><br><span class="line"></span><br><span class="line">                    var body = System.Text.Encoding.UTF8.GetBytes(message);</span><br><span class="line">                    </span><br><span class="line">                    channel.BasicPublish(exchange: ExchangeName,</span><br><span class="line">                        routingKey:severity,</span><br><span class="line">                        basicProperties:null,</span><br><span class="line">                        body:body);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [x] Sent &#x27;&#123;0&#125;&#x27;:&#x27;&#123;1&#125;&#x27;&quot;, severity, message);</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="消费者："><a href="#消费者：" class="headerlink" title="消费者："></a>消费者：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace RoutingMQConsumer1</span><br><span class="line">&#123;</span><br><span class="line">    class ReceiveLogsDirect</span><br><span class="line">    &#123;</span><br><span class="line">        static string ExchangeName = &quot;direct_logs&quot;;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    // 设置交换机以及交换机模式</span><br><span class="line">                    channel.ExchangeDeclare(exchange: ExchangeName,</span><br><span class="line">                        type: ExchangeType.Direct,</span><br><span class="line">                        durable:true);</span><br><span class="line"></span><br><span class="line">                    //获取当前消息队列名称</span><br><span class="line">                    var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line"></span><br><span class="line">                    if (args.Length &lt; 1)</span><br><span class="line">                    &#123;</span><br><span class="line">                        Console.Error.WriteLine(&quot;Usage: &#123;0&#125; [info] [warning] [error]&quot;,</span><br><span class="line">                                        Environment.GetCommandLineArgs()[0]);</span><br><span class="line">                        Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                        Console.ReadLine();</span><br><span class="line">                        Environment.ExitCode = 1;</span><br><span class="line">                        return;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    //当前消息队列 和 指定交换机的路由进行 绑定</span><br><span class="line">                    foreach (var severity in args)</span><br><span class="line">                    &#123;</span><br><span class="line">                        channel.QueueBind(queue: queueName,</span><br><span class="line">                            exchange: ExchangeName,</span><br><span class="line">                            routingKey: severity);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [*] Waiting for message.&quot;);</span><br><span class="line"></span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">                    consumer.Received += (sender, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var body = ea.Body;</span><br><span class="line">                        var message = Encoding.UTF8.GetString(body);</span><br><span class="line">                        var routingKey = ea.RoutingKey;</span><br><span class="line">                        Console.WriteLine(&quot; [x] Received &#x27;&#123;0&#125;&#x27;:&#x27;&#123;1&#125;&#x27;&quot;,</span><br><span class="line">                                          routingKey, message);</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    channel.BasicConsume(queue: queueName,</span><br><span class="line">                        noAck: true,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p>添加交换机</p><img src="/2020/10/24/mq/rabbitmq-model-routing/routingmq-addexchange.png" class="" title="Queue"> <img src="/2020/10/24/mq/rabbitmq-model-routing/routingmq-addexchange2.png" class="" title="Queue"> <h3 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h3><p>消费者1 监听 <strong>error</strong> 和 <strong>info</strong> 两个路由</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/RoutingMQConsumer1.exe error info</span><br></pre></td></tr></table></figure><p>消费者2 只监听 <strong>error</strong> 路由<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/RoutingMQConsumer1.exe error</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>生产者 分别对 <strong>info/error/warn</strong> 路由 各发送一条纤细<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/RoutingMQProduct.exe info hhh</span><br><span class="line">$ ./bin/Debug/RoutingMQProduct.exe error 11111</span><br><span class="line">$ ./bin/Debug/RoutingMQProduct.exe warn www</span><br></pre></td></tr></table></figure></p><img src="/2020/10/24/mq/rabbitmq-model-routing/routingmq-test.png" class="" title="Queue"> <h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;路由模式&lt;/p&gt;
&lt;h3 id=&quot;Routing-路由模式&quot;&gt;&lt;a href=&quot;#Routing-路由模式&quot; class=&quot;headerlink&quot; title=&quot;Routing 路由模式&quot;&gt;&lt;/a&gt;Routing 路由模式&lt;/h3&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR;
    id1([Product]);
    id2([ExChange]);
    id3([amq.gen-DjtYso1eaz52eM3mAJToaw])
    id4([amq.gen-nLrD6gHpPBMY-oqM-tBVcQ])
    id5([C1])
    id6([C2])

    style id1 fill:#0ff,stroke:#333;
    style id2 fill:#33c,stroke:#333;
    style id3 fill:#f00,stroke:#333;
    style id4 fill:#f00,stroke:#333;
    style id5 fill:#3cf,stroke:#333;
    style id6 fill:#3cf,stroke:#333;

    id1--&gt;id2;

    id2--&gt;|error|id3;
    id3--&gt;id5;

    id2--&gt;|error|id4;
    id2--&gt;|info|id4;

    id4--&gt;id6;&lt;/pre&gt;

&lt;p&gt;注意&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生产者发送消息到交换机，要指定路由Key&lt;/li&gt;
&lt;li&gt;消费者将队列绑定到交换机时需要指定路由Key&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这个是一种 &lt;strong&gt;完全匹配&lt;/strong&gt; 只有匹配到的消费者才能消费消息&lt;/p&gt;
&lt;p&gt;消息中的路由键值如果和Binding中的binding key 一致，交换机就将消息发送到对应的队列中。&lt;br&gt;路由键与队列名完全匹配，如果一个队列绑定到交换机要求路由键为”dog”,则只转发routingkey 标记为”dog”的消息,不会转发”dog.puppy”,也不会转发”dog.guard”等等。这个是时 &lt;strong&gt;完全匹配&lt;/strong&gt;、单播的模式&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ RPC Model</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-rpc/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-rpc/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:38.275Z</updated>
    
    <content type="html"><![CDATA[<p>RPC——Remote Procedure Call，远程过程调用。 那RabbitMQ如何进行远程调用呢？</p><h2 id="示意图"><a href="#示意图" class="headerlink" title="示意图"></a>示意图</h2><p>如下：</p><img src="/2020/10/24/mq/rabbitmq-model-rpc/rpc.png" class="" title="RPC"> <pre class="mermaid">graph TB;    C([Client]);    mq1([rpc_queue])    mq2([reply_to=amq.gen-..])    S([Server])    style C fill:#3cf,stroke:#333;    style mq1 fill:#f00,stroke:#333;    style mq2 fill:#f00,stroke:#333;    style S fill:#3cf,stroke:#333;    C-->|Request reply_to=amq.gen-.. correlation_id=abc |mq1;    mq1-->S;    S-->mq2;    mq2-->|Reply correlation_id=abc|C;</pre><h2 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h2><ul><li>第一步，主要是进行远程调用的客户端需要指定接收远程回调的队列，并申明消费者监听此队列。 </li><li>第二步，远程调用的服务端除了要申明消费端接收远程调用请求外，还要将结果发送到客户端用来监听回调结果的队列中去。</li></ul><span id="more"></span><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><p>客户端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><span class="line">using System;</span><br><span class="line">using System.Collections.Concurrent;</span><br><span class="line">using System.Text;</span><br><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line"></span><br><span class="line">public class RpcClient</span><br><span class="line">&#123;</span><br><span class="line">    private readonly IConnection connection;</span><br><span class="line">    private readonly IModel channel;</span><br><span class="line">    private readonly string replyQueueName;</span><br><span class="line">    private readonly EventingBasicConsumer consumer;</span><br><span class="line">    private readonly BlockingCollection&lt;string&gt; respQueue = new BlockingCollection&lt;string&gt;();</span><br><span class="line">    private readonly IBasicProperties props;</span><br><span class="line"></span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 队列名</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    static string QueueName = &quot;rpc_queue&quot;;</span><br><span class="line"></span><br><span class="line">    public RpcClient()</span><br><span class="line">    &#123;</span><br><span class="line">        var factory = new ConnectionFactory()</span><br><span class="line">        &#123;</span><br><span class="line">            HostName = &quot;localhost&quot;,</span><br><span class="line">            VirtualHost = &quot;frexport&quot;</span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">        connection = factory.CreateConnection();</span><br><span class="line">        channel = connection.CreateModel();</span><br><span class="line"></span><br><span class="line">        //创建一个回调MQ队列,获取消息队列名</span><br><span class="line">        replyQueueName = channel.QueueDeclare().QueueName;</span><br><span class="line">        //创建自动队列的消费者，接收此队列的消息</span><br><span class="line">        consumer = new EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">        //创建消息信息,在信息里面填入消息回调参数，让服务器知道消息来源</span><br><span class="line">        props = channel.CreateBasicProperties();</span><br><span class="line">        var correlationId = Guid.NewGuid().ToString();</span><br><span class="line">        props.CorrelationId = correlationId;</span><br><span class="line">        props.ReplyTo = replyQueueName;</span><br><span class="line"></span><br><span class="line">        //消息消费</span><br><span class="line">        consumer.Received += (model, ea) =&gt;</span><br><span class="line">        &#123;</span><br><span class="line">            var body = ea.Body;</span><br><span class="line">            var response = Encoding.UTF8.GetString(body);</span><br><span class="line">            if (ea.BasicProperties.CorrelationId == correlationId)</span><br><span class="line">            &#123;</span><br><span class="line">                respQueue.Add(response);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public string Call(string message)</span><br><span class="line">    &#123;</span><br><span class="line">        var messageBytes = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">        //发送消息</span><br><span class="line">        channel.BasicPublish(</span><br><span class="line">            exchange: &quot;&quot;,</span><br><span class="line">            routingKey: QueueName,</span><br><span class="line">            basicProperties: props,</span><br><span class="line">            body: messageBytes);</span><br><span class="line"></span><br><span class="line">        //接收回调消息</span><br><span class="line">        channel.BasicConsume(</span><br><span class="line">            consumer: consumer,</span><br><span class="line">            queue: replyQueueName,</span><br><span class="line">            noAck: true);</span><br><span class="line">        //如果有回调，则respQueue有数据，返回，否则线程会阻塞在这个位置</span><br><span class="line">        return respQueue.Take();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void Close()</span><br><span class="line">    &#123;</span><br><span class="line">        connection.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">public class Rpc</span><br><span class="line">&#123;</span><br><span class="line">    public static void Main()</span><br><span class="line">    &#123;</span><br><span class="line">        var rpcClient = new RpcClient();</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot; [x] Requesting fib(30)&quot;);</span><br><span class="line">        var response = rpcClient.Call(&quot;30&quot;);</span><br><span class="line"></span><br><span class="line">        Console.WriteLine(&quot; [.] Got &#x27;&#123;0&#125;&#x27;&quot;, response);</span><br><span class="line">        rpcClient.Close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace RPCServer</span><br><span class="line">&#123;</span><br><span class="line">    class RPCServer</span><br><span class="line">    &#123;</span><br><span class="line">        static string QueueName = &quot;rpc_queue&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var conn = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = conn.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //定义消息队列</span><br><span class="line">                    channel.QueueDeclare(queue: QueueName,</span><br><span class="line">                        durable: true,</span><br><span class="line">                        exclusive: false,</span><br><span class="line">                        autoDelete: false,</span><br><span class="line">                        arguments: null);</span><br><span class="line">                    //消费者建立</span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">                    Console.WriteLine(&quot; [x] Awaiting RPC requests&quot;);</span><br><span class="line"></span><br><span class="line">                    //消息处理</span><br><span class="line">                    consumer.Received += (sender, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        string response = null;</span><br><span class="line"></span><br><span class="line">                        var body = ea.Body;</span><br><span class="line"></span><br><span class="line">                        var props = ea.BasicProperties;</span><br><span class="line"></span><br><span class="line">                        //回调属性带上 CorrelationId，以便客户端识别</span><br><span class="line">                        var replyProps = channel.CreateBasicProperties();</span><br><span class="line">                        replyProps.CorrelationId = props.CorrelationId; </span><br><span class="line"></span><br><span class="line">                        try</span><br><span class="line">                        &#123;</span><br><span class="line">                            var message = Encoding.UTF8.GetString(body);</span><br><span class="line">                            int n = int.Parse(message);</span><br><span class="line">                            Console.WriteLine(&quot; [.] fib(&#123;0&#125;)&quot;, message);</span><br><span class="line">                            response = fib(n).ToString();</span><br><span class="line">                        &#125;</span><br><span class="line">                        catch (Exception e)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Console.WriteLine(&quot; [.] &quot; + e.Message);</span><br><span class="line">                            response = &quot;&quot;;</span><br><span class="line">                        &#125;</span><br><span class="line">                        finally</span><br><span class="line">                        &#123;</span><br><span class="line">                            var responseBytes = Encoding.UTF8.GetBytes(response);</span><br><span class="line"></span><br><span class="line">                            //消息从回调通道，发送RabbitMQ</span><br><span class="line">                            channel.BasicPublish(exchange: &quot;&quot;, </span><br><span class="line">                                routingKey: props.ReplyTo, </span><br><span class="line">                                basicProperties: replyProps, </span><br><span class="line">                                body: responseBytes);</span><br><span class="line">                            //手动完成消息</span><br><span class="line">                            channel.BasicAck(deliveryTag: ea.DeliveryTag, </span><br><span class="line">                                multiple: false);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    //消费消息</span><br><span class="line">                    channel.BasicConsume(queue: QueueName,</span><br><span class="line">                        noAck: false,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    //这个位置必须要加入 Console.ReadLine(); 否则程序继续往下执行，channel和conn 会被销毁，通道会断开</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /// &lt;summary&gt;</span><br><span class="line">        /// 求 fib 数</span><br><span class="line">        /// &lt;/summary&gt;</span><br><span class="line">        /// &lt;param name=&quot;n&quot;&gt;&lt;/param&gt;</span><br><span class="line">        /// &lt;returns&gt;&lt;/returns&gt;</span><br><span class="line">        private static int fib(int n)</span><br><span class="line">        &#123;</span><br><span class="line">            if (n == 0 || n == 1)</span><br><span class="line">            &#123;</span><br><span class="line">                return n;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            return fib(n - 1) + fib(n - 2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>演示</p><img src="/2020/10/24/mq/rabbitmq-model-rpc/rpc-test.png" class="" title="RPC"> <h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RPC——Remote Procedure Call，远程过程调用。 那RabbitMQ如何进行远程调用呢？&lt;/p&gt;
&lt;h2 id=&quot;示意图&quot;&gt;&lt;a href=&quot;#示意图&quot; class=&quot;headerlink&quot; title=&quot;示意图&quot;&gt;&lt;/a&gt;示意图&lt;/h2&gt;&lt;p&gt;如下：&lt;/p&gt;
&lt;img src=&quot;/2020/10/24/mq/rabbitmq-model-rpc/rpc.png&quot; class=&quot;&quot; title=&quot;RPC&quot;&gt; 
&lt;pre class=&quot;mermaid&quot;&gt;graph TB;
    C([Client]);
    mq1([rpc_queue])
    mq2([reply_to=amq.gen-..])
    S([Server])

    style C fill:#3cf,stroke:#333;
    style mq1 fill:#f00,stroke:#333;
    style mq2 fill:#f00,stroke:#333;
    style S fill:#3cf,stroke:#333;

    C--&gt;|Request reply_to=amq.gen-.. correlation_id=abc |mq1;
    mq1--&gt;S;

    S--&gt;mq2;
    mq2--&gt;|Reply correlation_id=abc|C;&lt;/pre&gt;

&lt;h2 id=&quot;解释&quot;&gt;&lt;a href=&quot;#解释&quot; class=&quot;headerlink&quot; title=&quot;解释&quot;&gt;&lt;/a&gt;解释&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;第一步，主要是进行远程调用的客户端需要指定接收远程回调的队列，并申明消费者监听此队列。 &lt;/li&gt;
&lt;li&gt;第二步，远程调用的服务端除了要申明消费端接收远程调用请求外，还要将结果发送到客户端用来监听回调结果的队列中去。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ Hello Model</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-simple/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-simple/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:44.510Z</updated>
    
    <content type="html"><![CDATA[<p>简单模式</p><h3 id="简单模式"><a href="#简单模式" class="headerlink" title="简单模式"></a>简单模式</h3><p>一个生产者对一个消费者</p><pre class="mermaid">graph LR;    id1([Product]);    id2([Consumer]);    id3([Message Quene])    style id1 fill:#0ff,stroke:#333;    style id2 fill:#3cf,stroke:#333;    style id3 fill:#f00,stroke:#333;    id1-->id3;    id3-->id2;</pre><ul><li>Product : 发送消息</li><li>Consumer : 消费者 接受消息</li><li>Message Quene 消息队列,消息只会存储在队列中，不会处理，等待Consumer处理</li></ul><p>请注意，生产者，消费者和经纪人不必位于同一主机上。实际上，在大多数应用程序中它们不是。一个应用程序既可以是生产者，也可以是消费者。</p><p>RabbitMQ使用多种协议。本教程使用AMQP 0-9-1，这是一种开放的通用消息传递协议。RabbitMQ有许多不同语言的客户。我们将使用RabbitMQ提供的.NET客户端。</p><p>环境</p><ul><li>Net 35</li><li>RabbitMQ 3.4.3 <a href="RabbitMQ.Client.dll" title="源码下载">点击下载</a> </li></ul><span id="more"></span><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><p>新建项目 .net35 控制台项目 </p><p>SimpleMQProduct</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 生产者</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">namespace SimpleMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    class Send</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //定义连接工厂</span><br><span class="line">            var factory = new ConnectionFactory() &#123; HostName = &quot;127.0.0.1&quot; &#125;;</span><br><span class="line">            //通过工厂获取连接</span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                //创建通道</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //声明创建队列</span><br><span class="line">                    channel.QueueDeclare(queue: &quot;hello&quot;,</span><br><span class="line">                                        durable: false,</span><br><span class="line">                                        exclusive: false,</span><br><span class="line">                                        autoDelete: false,</span><br><span class="line">                                        arguments: null);</span><br><span class="line">                    //消息内容</span><br><span class="line">                    string message = &quot;Hello,World!&quot;;</span><br><span class="line">                    var body = Encoding.UTF8.GetBytes(message);</span><br><span class="line">                    //发送消息</span><br><span class="line">                    channel.BasicPublish(exchange: &quot;&quot;,</span><br><span class="line">                        routingKey: &quot;hello&quot;,</span><br><span class="line">                        basicProperties: null,</span><br><span class="line">                        body: body);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [x] Send &#123;0&#125;&quot;, message);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><p>新建项目 .net35 控制台项目 </p><p>SimpleMQConsumer</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System.Text;</span><br><span class="line">using System;</span><br><span class="line">/// &lt;summary&gt;</span><br><span class="line">/// 消费者</span><br><span class="line">/// &lt;/summary&gt;</span><br><span class="line">namespace SimpleMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class Receive</span><br><span class="line">    &#123;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            //定义连接工厂</span><br><span class="line">            var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot; &#125;;</span><br><span class="line">            //通过工厂获取连接</span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                //创建通道</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //声明通道</span><br><span class="line">                    channel.QueueDeclare(queue: &quot;hello&quot;,</span><br><span class="line">                        durable: false,</span><br><span class="line">                        exclusive: false,</span><br><span class="line">                        autoDelete: false,</span><br><span class="line">                        arguments: null);</span><br><span class="line"></span><br><span class="line">                    //定义消费者</span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">                    //消息接收后处理</span><br><span class="line">                    consumer.Received += (model, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var body = ea.Body;</span><br><span class="line">                        var message = Encoding.UTF8.GetString(body);</span><br><span class="line">                        Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">                    &#125;;</span><br><span class="line">                    //监听队列 noAck:True ,自动消费模式; 消息消费时无需给MQ返回Ack</span><br><span class="line">                    channel.BasicConsume(queue: &quot;hello&quot;,</span><br><span class="line">                        noAck: true,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit!&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>通过 ConnectionFactory 设置 RabbitMQ 连接参数<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot;, Port=5672, UserName = &quot;guest&quot;, Password = &quot;guest&quot;, VirtualHost = &quot;frexport&quot; &#125;;</span><br></pre></td></tr></table></figure></p><p>这里的参数</p><div class="table-container"><table><thead><tr><th>参数</th><th>参数类型</th><th>参数说明</th><th>默认值</th></tr></thead><tbody><tr><td>HostName</td><td>string</td><td>主机的IP</td><td></td></tr><tr><td>Port</td><td>int</td><td>主机通信端口</td><td>5672</td></tr><tr><td>UserName</td><td>string</td><td>连接账户</td><td>guest</td></tr><tr><td>Password</td><td>string</td><td>连接账户密码</td><td>guest</td></tr><tr><td>VirtualHost</td><td>string</td><td>访问的虚拟主机,可以理解为一个应用MQ</td><td>/</td></tr></tbody></table></div><p>对应的RabbitMQ操作</p><h3 id="RabbitMQ-控制台操作"><a href="#RabbitMQ-控制台操作" class="headerlink" title="RabbitMQ 控制台操作"></a>RabbitMQ 控制台操作</h3><ol><li>添加guest用户</li></ol><p>guest用户设置密码为 guest</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-adduser1.png" class="" title="添加guest"> <img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-adduser2.png" class="" title="添加guest2"> <ol><li>添加 vhost -&gt; frexport</li></ol><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-addvhost1.png" class="" title="添加vhost"> <p>设置VHost权限，添加guest用户权限</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-setvhost1.png" class="" title="设置权限"> <p>设置后如下</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-setvhost2.png" class="" title="添加vhost"> <p>回到User界面</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-setvhost3.png" class="" title="添加vhost"> <ol><li>添加Quene 队列 hello</li></ol><p>我们使用 frexport 虚拟主机创建一个队列 hello</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-addquene1.png" class="" title="添加队列1"> <p>添加后</p><img src="/2020/10/24/mq/rabbitmq-model-simple/rabbitmq-addquene2.png" class="" title="添加队列2"> <h3 id="运行程序"><a href="#运行程序" class="headerlink" title="运行程序"></a>运行程序</h3><p>Product</p><img src="/2020/10/24/mq/rabbitmq-model-simple/samplemq-product.png" class="" title="生产者"> <p>Consumer</p><img src="/2020/10/24/mq/rabbitmq-model-simple/samplemq-consumer.png" class="" title="消费者"> <h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;简单模式&lt;/p&gt;
&lt;h3 id=&quot;简单模式&quot;&gt;&lt;a href=&quot;#简单模式&quot; class=&quot;headerlink&quot; title=&quot;简单模式&quot;&gt;&lt;/a&gt;简单模式&lt;/h3&gt;&lt;p&gt;一个生产者对一个消费者&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph LR;
    id1([Product]);
    id2([Consumer]);
    id3([Message Quene])
    style id1 fill:#0ff,stroke:#333;
    style id2 fill:#3cf,stroke:#333;
    style id3 fill:#f00,stroke:#333;
    id1--&gt;id3;
    id3--&gt;id2;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;Product : 发送消息&lt;/li&gt;
&lt;li&gt;Consumer : 消费者 接受消息&lt;/li&gt;
&lt;li&gt;Message Quene 消息队列,消息只会存储在队列中，不会处理，等待Consumer处理&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;请注意，生产者，消费者和经纪人不必位于同一主机上。实际上，在大多数应用程序中它们不是。一个应用程序既可以是生产者，也可以是消费者。&lt;/p&gt;
&lt;p&gt;RabbitMQ使用多种协议。本教程使用AMQP 0-9-1，这是一种开放的通用消息传递协议。RabbitMQ有许多不同语言的客户。我们将使用RabbitMQ提供的.NET客户端。&lt;/p&gt;
&lt;p&gt;环境&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Net 35&lt;/li&gt;
&lt;li&gt;RabbitMQ 3.4.3 &lt;a href=&quot;RabbitMQ.Client.dll&quot; title=&quot;源码下载&quot;&gt;点击下载&lt;/a&gt; &lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 发布/订阅模式</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-subscribe/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-subscribe/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:48.772Z</updated>
    
    <content type="html"><![CDATA[<p>发布/订阅模式</p><h3 id="Publish-Subscribe-发布-订阅模式"><a href="#Publish-Subscribe-发布-订阅模式" class="headerlink" title="Publish/Subscribe 发布/订阅模式"></a>Publish/Subscribe 发布/订阅模式</h3><p>一个生成者对应多个消费者</p><p>之前我们创建了一个工作队列。工作队列背后的假设是，每个任务都恰好交付给一个工人。<br>在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布/订阅”。</p><p>为了说明这种模式，我们将构建一个简单的日志记录系统。它包含两个程序-第一个程序将发出日志消息，第二个程序将接收并打印它们。</p><pre class="mermaid">graph LR;    id1([Product]);    id2([ExChange]);    id3([amq.gen-2G4YaJ2P3JcJEwHHiRL5JA])    id4([amq.gen-tsfVrHogVGKF3vGv6-rPWg])    id5([C1])    id6([C2])    style id1 fill:#0ff,stroke:#333;    style id2 fill:#33c,stroke:#333;    style id3 fill:#f00,stroke:#333;    style id4 fill:#f00,stroke:#333;    style id5 fill:#3cf,stroke:#333;    style id6 fill:#3cf,stroke:#333;    id1-->id2;    id2-->id3-->id5;    id2-->id4-->id6;</pre><ul><li>生产者：将消息发送到 交换机/队列</li><li>消费者：只能从队列中获取消息</li><li>队列可以绑定交换机</li></ul><p>如果消息发送到没有队列绑定的交换机上,那么消息将丢失</p><span id="more"></span><h3 id="生产者"><a href="#生产者" class="headerlink" title="生产者"></a>生产者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace SubscribeMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 发布订阅模式生产者 </span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line"></span><br><span class="line">    class EmitLog</span><br><span class="line">    &#123;</span><br><span class="line">        static string EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line"></span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot;, VirtualHost = &quot;frexport&quot; &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //声明交换机 fanout：交换机类型 主要有fanout,direct,topics三种</span><br><span class="line">                    channel.ExchangeDeclare(exchange: EXCHANGE_NAME,</span><br><span class="line">                        type: ExchangeType.Fanout,</span><br><span class="line">                        durable: true);</span><br><span class="line">                    for (int i = 0; i &lt; 10; i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        var message = &quot;Message-&quot; + i;</span><br><span class="line">                        var body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                        //发送消息</span><br><span class="line">                        channel.BasicPublish(exchange: EXCHANGE_NAME,</span><br><span class="line">                            routingKey: &quot;&quot;,</span><br><span class="line">                            basicProperties: null,</span><br><span class="line">                            body: body);</span><br><span class="line">                        Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="消费者"><a href="#消费者" class="headerlink" title="消费者"></a>消费者</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace SubscribeMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    /// &lt;summary&gt;</span><br><span class="line">    /// 发布订阅模式消费者</span><br><span class="line">    /// &lt;/summary&gt;</span><br><span class="line">    class ReceiveLogs</span><br><span class="line">    &#123;</span><br><span class="line">        static string EXCHANGE_NAME = &quot;logs&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory() &#123; HostName = &quot;localhost&quot;, VirtualHost = &quot;frexport&quot; &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    //声明 交换机</span><br><span class="line">                    channel.ExchangeDeclare(exchange: EXCHANGE_NAME,</span><br><span class="line">                        type: ExchangeType.Fanout,</span><br><span class="line">                        durable:true);</span><br><span class="line"></span><br><span class="line">                    var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line"></span><br><span class="line">                    //队列和交换机绑定</span><br><span class="line">                    channel.QueueBind(queue: queueName,</span><br><span class="line">                        exchange: EXCHANGE_NAME,</span><br><span class="line">                        routingKey: &quot;&quot;);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [*] Waiting for logs.&quot;);</span><br><span class="line"></span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">                    consumer.Received += (sender, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var body = ea.Body;</span><br><span class="line">                        var message = Encoding.UTF8.GetString(body);</span><br><span class="line">                        Console.WriteLine(&quot; [x] &#123;0&#125;&quot;, message);</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    channel.BasicConsume(queue: queueName,</span><br><span class="line">                        noAck: true,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p>添加交换机</p><img src="/2020/10/24/mq/rabbitmq-model-subscribe/subsrcibemq-addexchange1.png" class="" title="Queue"> <img src="/2020/10/24/mq/rabbitmq-model-subscribe/subsrcibemq-addexchange2.png" class="" title="Queue"> <h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><img src="/2020/10/24/mq/rabbitmq-model-subscribe/subsrcibemq-test.png" class="" title="Queue"> <p>还可以看RabbitMQ 自动生成了两个队列绑定路由</p><img src="/2020/10/24/mq/rabbitmq-model-subscribe/subsrcibemq-autoqueue.png" class="" title="Queue"> <h3 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h3><p>这个模式下，消息会被交换机转发给每个订阅者，每个订阅消费者都会在MQ端有一个Queue队列。<br>生产者的消息会转到所有绑定交换机的队列上，消费者消费所有队列消息</p><h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;发布/订阅模式&lt;/p&gt;
&lt;h3 id=&quot;Publish-Subscribe-发布-订阅模式&quot;&gt;&lt;a href=&quot;#Publish-Subscribe-发布-订阅模式&quot; class=&quot;headerlink&quot; title=&quot;Publish/Subscribe 发布/订阅模式&quot;&gt;&lt;/a&gt;Publish/Subscribe 发布/订阅模式&lt;/h3&gt;&lt;p&gt;一个生成者对应多个消费者&lt;/p&gt;
&lt;p&gt;之前我们创建了一个工作队列。工作队列背后的假设是，每个任务都恰好交付给一个工人。&lt;br&gt;在这一部分中，我们将做一些完全不同的事情-我们将消息传达给多个消费者。这种模式称为“发布/订阅”。&lt;/p&gt;
&lt;p&gt;为了说明这种模式，我们将构建一个简单的日志记录系统。它包含两个程序-第一个程序将发出日志消息，第二个程序将接收并打印它们。&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph LR;
    id1([Product]);
    id2([ExChange]);
    id3([amq.gen-2G4YaJ2P3JcJEwHHiRL5JA])
    id4([amq.gen-tsfVrHogVGKF3vGv6-rPWg])
    id5([C1])
    id6([C2])

    style id1 fill:#0ff,stroke:#333;
    style id2 fill:#33c,stroke:#333;
    style id3 fill:#f00,stroke:#333;
    style id4 fill:#f00,stroke:#333;
    style id5 fill:#3cf,stroke:#333;
    style id6 fill:#3cf,stroke:#333;

    id1--&gt;id2;

    id2--&gt;id3--&gt;id5;
    id2--&gt;id4--&gt;id6;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;生产者：将消息发送到 交换机/队列&lt;/li&gt;
&lt;li&gt;消费者：只能从队列中获取消息&lt;/li&gt;
&lt;li&gt;队列可以绑定交换机&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;如果消息发送到没有队列绑定的交换机上,那么消息将丢失&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ Topics 主题模式</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-topics/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-topics/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:52.757Z</updated>
    
    <content type="html"><![CDATA[<p>主题模式</p><h3 id="Topics-主题模式"><a href="#Topics-主题模式" class="headerlink" title="Topics 主题模式"></a>Topics 主题模式</h3><p>主题模式类似 路由模式</p><p>路由模式是 <strong>完全匹配</strong> 模式，主题模式匹配 通配符</p><p><pre class="mermaid">graph LR;<br>    p([Product]);<br>    ex([ExChange]);<br>    mq1([amq.gen-fMFRcKxaTxM-o_ApPe_AHw])<br>    mq2([amq.gen-jWFR9bCh4_b52j6KUDt1Sw])<br>    mq3([amq.gen-kkOjkWx9if2mQB_3gcfO4w])<br>    mq4([amq.gen-tNqCT75w_QqSJbVKrJapQQ])<br>    c1([C1])<br>    c2([C2])<br>    c3([C3])<br>    c4([C4])</p><pre><code>style p fill:#0ff,stroke:#333;style ex fill:#33c,stroke:#333;style mq1 fill:#f00,stroke:#333;style mq2 fill:#f00,stroke:#333;style mq3 fill:#f00,stroke:#333;style mq4 fill:#f00,stroke:#333;style c1 fill:#3cf,stroke:#333;style c2 fill:#3cf,stroke:#333;style c3 fill:#3cf,stroke:#333;style c4 fill:#3cf,stroke:#333;p--&gt;ex;ex--&gt;|#|mq1;mq1--&gt;c1;ex--&gt;|kern.*|mq2;mq2--&gt;c2;ex--&gt;|*.critical|mq3;mq3--&gt;c3;ex--&gt;|kern.*|mq4;ex--&gt;|*.critical|mq4;mq4--&gt;c4;&lt;/pre&gt;</code></pre><span id="more"></span><h3 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码:"></a>生产者代码:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace TopicsMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class EmitLogTopic</span><br><span class="line">    &#123;</span><br><span class="line">        static string ExchangeName = &quot;topic_logs&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            using (var channel = connection.CreateModel())</span><br><span class="line">            &#123;</span><br><span class="line">                // 设置交换机以及交换机模式  durable 不设置的话,默认为false</span><br><span class="line">                channel.ExchangeDeclare(exchange: ExchangeName,</span><br><span class="line">                                        type: ExchangeType.Topic,</span><br><span class="line">                                        durable: false);</span><br><span class="line">                //路由信息</span><br><span class="line">                var routingKey = (args.Length &gt; 0) ? args[0] : &quot;anonymous.info&quot;;</span><br><span class="line"></span><br><span class="line">                //消息</span><br><span class="line">                var message = (args.Length &gt; 1) ? args[1] : &quot;HelloWorld!&quot;;</span><br><span class="line">                var body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                channel.BasicPublish(exchange: ExchangeName,</span><br><span class="line">                                     routingKey: routingKey,</span><br><span class="line">                                     basicProperties: null,</span><br><span class="line">                                     body: body);</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot; [x] Sent &#x27;&#123;0&#125;&#x27;:&#x27;&#123;1&#125;&#x27;&quot;, routingKey, message);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line"></span><br><span class="line">namespace TopicsMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class ReceiveLogsTopic</span><br><span class="line">    &#123;</span><br><span class="line">        static string ExchangeName = &quot;topic_logs&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            using (var channel = connection.CreateModel())</span><br><span class="line">            &#123;</span><br><span class="line">                // 设置交换机以及交换机模式  durable 不设置的话,默认为false</span><br><span class="line">                channel.ExchangeDeclare(exchange: ExchangeName,</span><br><span class="line">                                        type: ExchangeType.Topic,</span><br><span class="line">                                        durable: false);</span><br><span class="line"></span><br><span class="line">                var queueName = channel.QueueDeclare().QueueName;</span><br><span class="line"></span><br><span class="line">                if (args.Length &lt; 1)</span><br><span class="line">                &#123;</span><br><span class="line">                    Console.Error.WriteLine(&quot;Usage: &#123;0&#125; [binding_key...]&quot;,</span><br><span class="line">                                            Environment.GetCommandLineArgs()[0]);</span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                    Environment.ExitCode = 1;</span><br><span class="line">                    return;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                //消息队列 绑定到 对应交换机的路由上</span><br><span class="line">                foreach (var bindingKey in args)</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.QueueBind(queue: queueName,</span><br><span class="line">                                      exchange: ExchangeName,</span><br><span class="line">                                      routingKey: bindingKey);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot; [*] Waiting for messages. To exit press CTRL+C&quot;);</span><br><span class="line"></span><br><span class="line">                var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">                consumer.Received += (model, ea) =&gt;</span><br><span class="line">                &#123;</span><br><span class="line">                    var body = ea.Body.ToArray();</span><br><span class="line">                    var message = Encoding.UTF8.GetString(body);</span><br><span class="line">                    var routingKey = ea.RoutingKey;</span><br><span class="line">                    Console.WriteLine(&quot; [x] Received &#x27;&#123;0&#125;&#x27;:&#x27;&#123;1&#125;&#x27;&quot;,</span><br><span class="line">                                      routingKey,</span><br><span class="line">                                      message);</span><br><span class="line">                &#125;;</span><br><span class="line"></span><br><span class="line">                channel.BasicConsume(queue: queueName,</span><br><span class="line">                                     noAck: true,</span><br><span class="line">                                     consumer: consumer);</span><br><span class="line"></span><br><span class="line">                Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                Console.ReadLine();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="配置RabbitMQ"><a href="#配置RabbitMQ" class="headerlink" title="配置RabbitMQ"></a>配置RabbitMQ</h3><p>添加交换机</p><img src="/2020/10/24/mq/rabbitmq-model-topics/topicmq-addexchange.png" class="" title="Queue"> <img src="/2020/10/24/mq/rabbitmq-model-topics/topicmq-addexchange2.png" class="" title="Queue"> <h3 id="测试"><a href="#测试" class="headerlink" title="测试:"></a>测试:</h3><p>消费者1 监听 “#” 所有消息</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/TopicsMQConsumer.exe &quot;#&quot;</span><br></pre></td></tr></table></figure><p>消费者2 只监听 kern.* 通配符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/TopicsMQConsumer.exe &quot;kern.*&quot;</span><br></pre></td></tr></table></figure></p><p>消费者3 只监听 “*.critical” 通配符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/TopicsMQConsumer.exe &quot;*.critical&quot;</span><br></pre></td></tr></table></figure></p><p>消费者4 监听 “kern.<em>“ “</em>.critical” 通配符<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/TopicsMQConsumer.exe &quot;kern.*&quot; &quot;*.critical&quot;</span><br></pre></td></tr></table></figure></p><p>生产者发送消息<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kern.critic wwww</span><br><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kern.1 wwww</span><br><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kwww wwww</span><br><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kwww.critic wwww</span><br><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kwww.criticical wwww</span><br><span class="line">$ ./bin/Debug/TopicsMQProduct.exe kwww.critical wwww</span><br></pre></td></tr></table></figure></p><p>输出结果</p><img src="/2020/10/24/mq/rabbitmq-model-topics/topicmq-test.png" class="" title="Queue"> <h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;主题模式&lt;/p&gt;
&lt;h3 id=&quot;Topics-主题模式&quot;&gt;&lt;a href=&quot;#Topics-主题模式&quot; class=&quot;headerlink&quot; title=&quot;Topics 主题模式&quot;&gt;&lt;/a&gt;Topics 主题模式&lt;/h3&gt;&lt;p&gt;主题模式类似 路由模式&lt;/p&gt;
&lt;p&gt;路由模式是 &lt;strong&gt;完全匹配&lt;/strong&gt; 模式，主题模式匹配 通配符&lt;/p&gt;
&lt;p&gt;&lt;pre class=&quot;mermaid&quot;&gt;graph LR;&lt;br&gt;    p([Product]);&lt;br&gt;    ex([ExChange]);&lt;br&gt;    mq1([amq.gen-fMFRcKxaTxM-o_ApPe_AHw])&lt;br&gt;    mq2([amq.gen-jWFR9bCh4_b52j6KUDt1Sw])&lt;br&gt;    mq3([amq.gen-kkOjkWx9if2mQB_3gcfO4w])&lt;br&gt;    mq4([amq.gen-tNqCT75w_QqSJbVKrJapQQ])&lt;br&gt;    c1([C1])&lt;br&gt;    c2([C2])&lt;br&gt;    c3([C3])&lt;br&gt;    c4([C4])&lt;/p&gt;
&lt;pre&gt;&lt;code&gt;style p fill:#0ff,stroke:#333;
style ex fill:#33c,stroke:#333;
style mq1 fill:#f00,stroke:#333;
style mq2 fill:#f00,stroke:#333;
style mq3 fill:#f00,stroke:#333;
style mq4 fill:#f00,stroke:#333;
style c1 fill:#3cf,stroke:#333;
style c2 fill:#3cf,stroke:#333;
style c3 fill:#3cf,stroke:#333;
style c4 fill:#3cf,stroke:#333;

p--&amp;gt;ex;

ex--&amp;gt;|#|mq1;
mq1--&amp;gt;c1;

ex--&amp;gt;|kern.*|mq2;
mq2--&amp;gt;c2;

ex--&amp;gt;|*.critical|mq3;
mq3--&amp;gt;c3;

ex--&amp;gt;|kern.*|mq4;
ex--&amp;gt;|*.critical|mq4;
mq4--&amp;gt;c4;&amp;lt;/pre&amp;gt;
&lt;/code&gt;&lt;/pre&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ Work Queues</title>
    <link href="http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-work/"/>
    <id>http://blog.rcant.com/2020/10/24/mq/rabbitmq-model-work/</id>
    <published>2020-10-24T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:58.315Z</updated>
    
    <content type="html"><![CDATA[<p>工作队列</p><h3 id="Work-Queues-工作队列"><a href="#Work-Queues-工作队列" class="headerlink" title="Work Queues 工作队列"></a>Work Queues 工作队列</h3><p>工作队列背后的假设是，每个任务都恰好交付给一个工人</p><p>一个生成者对应多个消费者</p><pre class="mermaid">graph LR;    id1([Product]);    id2([Message Quene])    id3([Consumer1]);    id4([Consumer2]);    style id1 fill:#0ff,stroke:#333;    style id2 fill:#f00,stroke:#333;    style id3 fill:#3cf,stroke:#333;    style id4 fill:#3cf,stroke:#333;    id1-->id2;    id2-->id3;    id2-->id4;</pre><p>将比较复杂比较耗时的任务放在任务队列中，不必立即执行。</p><p>任务队列用来管理任务列表,我们在后台的工作可以交给多个线程来完成。</p><span id="more"></span><h3 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h3><p>创建两个工程一个作为生产者，一个作为消费者</p><p>这个时候的消费者，不能立即处理完一个事情，需要消耗一定时间</p><p>我们同时开启多个消费者消费任务。</p><p>生产者不停的生产新的任务</p><p>以下是代码</p><h4 id="生产者代码"><a href="#生产者代码" class="headerlink" title="生产者代码"></a>生产者代码</h4><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace WorkMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    class NewTask</span><br><span class="line">    &#123;</span><br><span class="line">        static string QueueName = &quot;task_queue&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;,</span><br><span class="line">                UserName = &quot;guest&quot;,</span><br><span class="line">                Password = &quot;guest&quot;</span><br><span class="line">            &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            using (var channel = connection.CreateModel())</span><br><span class="line">            &#123;</span><br><span class="line">                channel.QueueDeclare(queue: QueueName,</span><br><span class="line">                                     durable: true,</span><br><span class="line">                                     exclusive: false,</span><br><span class="line">                                     autoDelete: false,</span><br><span class="line">                                     arguments: null);</span><br><span class="line"></span><br><span class="line">                var properties = channel.CreateBasicProperties();</span><br><span class="line">                properties.SetPersistent(true);</span><br><span class="line"></span><br><span class="line">                for (int i = 0; i &lt; 40; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    var message = &quot;Task&quot; + i;</span><br><span class="line">                    var body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                    channel.BasicPublish(exchange: &quot;&quot;,</span><br><span class="line">                                     routingKey: QueueName,</span><br><span class="line">                                     basicProperties: properties,</span><br><span class="line">                                     body: body);</span><br><span class="line">                    Console.WriteLine(&quot; [x] Sent &#123;0&#125;&quot;, message);</span><br><span class="line">                    Thread.Sleep(100);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h4 id="消费者代码"><a href="#消费者代码" class="headerlink" title="消费者代码"></a>消费者代码</h4><p>同一队列可以有多个消费者同时消费<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Linq;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace WorkMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class Worker</span><br><span class="line">    &#123;</span><br><span class="line">        static string QueueName = &quot;task_queue&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory() &#123; &#125;;</span><br><span class="line">            factory.HostName = &quot;localhost&quot;;</span><br><span class="line">            factory.VirtualHost = &quot;frexport&quot;;</span><br><span class="line">            factory.UserName = &quot;guest&quot;;</span><br><span class="line">            factory.Password = &quot;guest&quot;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.QueueDeclare(queue: QueueName,</span><br><span class="line">                        durable: true,</span><br><span class="line">                        exclusive: false,</span><br><span class="line">                        autoDelete: false,</span><br><span class="line">                        arguments: null);</span><br><span class="line"></span><br><span class="line">                    //同一时刻服务器只发送一条消息给消费端</span><br><span class="line">                    channel.BasicQos(prefetchCount: 1, prefetchSize: 0, global: false);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [*] Waiting for message.&quot;);</span><br><span class="line"></span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">                    consumer.Received += (sender, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var body = ea.Body;</span><br><span class="line">                        var message = System.Text.Encoding.UTF8.GetString(body);</span><br><span class="line"></span><br><span class="line">                        Console.WriteLine(&quot; [x] Receive &#123;0&#125; &#123;1&#125;&quot;, message, DateTime.Now);</span><br><span class="line"></span><br><span class="line">                        Thread.Sleep(1000);</span><br><span class="line"></span><br><span class="line">                        //消息消费完给服务器返回确认状态，表示该消息已被消费</span><br><span class="line">                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    channel.BasicConsume(queue: QueueName,</span><br><span class="line">                        noAck: false,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><img src="/2020/10/24/mq/rabbitmq-model-work/workmq.png" class="" title="消费者"> <h3 id="当然需要添加Queue"><a href="#当然需要添加Queue" class="headerlink" title="当然需要添加Queue"></a>当然需要添加Queue</h3><img src="/2020/10/24/mq/rabbitmq-model-work/workmq-addqueue.png" class="" title="Queue"> <h3 id="消息消费的两种模式"><a href="#消息消费的两种模式" class="headerlink" title="消息消费的两种模式"></a>消息消费的两种模式</h3><h4 id="1-自动模式"><a href="#1-自动模式" class="headerlink" title="1. 自动模式"></a>1. 自动模式</h4><p>消费者从消息队列获取消息后，服务端就认为该消息已经成功消费。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var consumer = new EventingBasicConsumer(channel);</span><br><span class="line">consumer.Received += (model, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var body = ea.Body;</span><br><span class="line">    var message = Encoding.UTF8.GetString(body);</span><br><span class="line">    Console.WriteLine(&quot; [x] Received &#123;0&#125;&quot;, message);</span><br><span class="line">    //无需反馈</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queue: &quot;hello&quot;,</span><br><span class="line">    noAck: true,</span><br><span class="line">    consumer: consumer);</span><br></pre></td></tr></table></figure><h4 id="2-手动模式"><a href="#2-手动模式" class="headerlink" title="2. 手动模式"></a>2. 手动模式</h4><p>消费者从消息队列获取消息后，服务端并没有标记为成功消费<br>​消费者成功消费后需要将状态返回到服务端</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var consumer = new EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">consumer.Received += (sender, ea) =&gt;</span><br><span class="line">&#123;</span><br><span class="line">    var body = ea.Body;</span><br><span class="line">    var message = System.Text.Encoding.UTF8.GetString(body);</span><br><span class="line"></span><br><span class="line">    Console.WriteLine(&quot; [x] Receive &#123;0&#125; &#123;1&#125;&quot;, message, DateTime.Now);</span><br><span class="line"></span><br><span class="line">    Thread.Sleep(1000);</span><br><span class="line"></span><br><span class="line">    //消息消费完给服务器返回确认状态，表示该消息已被消费</span><br><span class="line">    channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">channel.BasicConsume(queue: QueueName,</span><br><span class="line">                noAck: false,</span><br><span class="line">                consumer: consumer);</span><br></pre></td></tr></table></figure><h2 id="RabbitMQ-Model介绍"><a href="#RabbitMQ-Model介绍" class="headerlink" title="RabbitMQ Model介绍"></a>RabbitMQ Model介绍</h2><ul><li><a href="/2020/10/24/mq/rabbitmq-model-simple/" title="RabbitMQ Hello Model">RabbitMQ Hello Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-work/" title="RabbitMQ WorkQueue Model">RabbitMQ WorkQueue Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-subscribe/" title="RabbitMQ Subscribe Model">RabbitMQ Subscribe Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-routing/" title="RabbitMQ Routing Model">RabbitMQ Routing Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-topics/" title="RabbitMQ Topics Model">RabbitMQ Topics Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-rpc/" title="RabbitMQ RPC Model">RabbitMQ RPC Model</a>  </li><li><a href="/2020/10/24/mq/rabbitmq-model-publish-confirm/" title="RabbitMQ 发布确认">RabbitMQ 发布确认</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作队列&lt;/p&gt;
&lt;h3 id=&quot;Work-Queues-工作队列&quot;&gt;&lt;a href=&quot;#Work-Queues-工作队列&quot; class=&quot;headerlink&quot; title=&quot;Work Queues 工作队列&quot;&gt;&lt;/a&gt;Work Queues 工作队列&lt;/h3&gt;&lt;p&gt;工作队列背后的假设是，每个任务都恰好交付给一个工人&lt;/p&gt;
&lt;p&gt;一个生成者对应多个消费者&lt;/p&gt;
&lt;pre class=&quot;mermaid&quot;&gt;graph LR;
    id1([Product]);
    id2([Message Quene])
    id3([Consumer1]);
    id4([Consumer2]);

    style id1 fill:#0ff,stroke:#333;
    style id2 fill:#f00,stroke:#333;
    style id3 fill:#3cf,stroke:#333;
    style id4 fill:#3cf,stroke:#333;

    id1--&gt;id2;

    id2--&gt;id3;
    id2--&gt;id4;&lt;/pre&gt;

&lt;p&gt;将比较复杂比较耗时的任务放在任务队列中，不必立即执行。&lt;/p&gt;
&lt;p&gt;任务队列用来管理任务列表,我们在后台的工作可以交给多个线程来完成。&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>阿里巴巴为什么能抗住90秒100亿？</title>
    <link href="http://blog.rcant.com/2020/10/23/framework/framework-alibaba/"/>
    <id>http://blog.rcant.com/2020/10/23/framework/framework-alibaba/</id>
    <published>2020-10-23T14:39:17.000Z</published>
    <updated>2023-01-06T09:36:13.418Z</updated>
    
    <content type="html"><![CDATA[<p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程</p><h2 id="1、-概述"><a href="#1、-概述" class="headerlink" title="1、 概述"></a>1、 概述</h2><p>本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。</p><h2 id="2、基本概念"><a href="#2、基本概念" class="headerlink" title="2、基本概念"></a>2、基本概念</h2><p>在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。</p><h3 id="1）什么是分布式？"><a href="#1）什么是分布式？" class="headerlink" title="1）什么是分布式？"></a>1）什么是分布式？</h3><p>系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。</p><h3 id="2）什么是高可用？"><a href="#2）什么是高可用？" class="headerlink" title="2）什么是高可用？"></a>2）什么是高可用？</h3><p>系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。</p><h3 id="3）什么是集群？"><a href="#3）什么是集群？" class="headerlink" title="3）什么是集群？"></a>3）什么是集群？</h3><p>一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。<br>如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。<br>在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。</p><h3 id="4）什么是负载均衡？"><a href="#4）什么是负载均衡？" class="headerlink" title="4）什么是负载均衡？"></a>4）什么是负载均衡？</h3><p>请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。</p><h3 id="5）什么是正向代理和反向代理？"><a href="#5）什么是正向代理和反向代理？" class="headerlink" title="5）什么是正向代理和反向代理？"></a>5）什么是正向代理和反向代理？</h3><p>系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；<br>当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。<br>简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。</p><span id="more"></span><h2 id="3、架构演进"><a href="#3、架构演进" class="headerlink" title="3、架构演进"></a>3、架构演进</h2><h3 id="3-1-单机架构"><a href="#3-1-单机架构" class="headerlink" title="3.1 单机架构"></a>3.1 单机架构</h3><img src="/2020/10/23/framework/framework-alibaba/1.webp" class="" title="单机架构"> <p>以淘宝作为例子：在网站最初时，应用数量与用户数都较少，可以把Tomcat和数据库部署在同一台服务器上。</p><p>浏览器往www.taobao.com发起请求时，首先经过DNS服务器（域名系统）把域名转换为实际IP地址10.102.4.1，浏览器转而访问该IP对应的Tomcat。</p><p>架构瓶颈：随着用户数的增长，Tomcat和数据库之间竞争资源，单机性能不足以支撑业务。</p><h3 id="3-2第一次演进：Tomcat与数据库分开部署"><a href="#3-2第一次演进：Tomcat与数据库分开部署" class="headerlink" title="3.2第一次演进：Tomcat与数据库分开部署"></a>3.2第一次演进：Tomcat与数据库分开部署</h3><img src="/2020/10/23/framework/framework-alibaba/2.webp" class="" title="Tomcat与数据库分开部署"> <p>Tomcat和数据库分别独占服务器资源，显著提高两者各自性能。</p><p>架构瓶颈：随着用户数的增长，并发读写数据库成为瓶颈。</p><p>Tips：欢迎关注微信公众号：Java后端，获取更多技术博文推送。</p><h3 id="3-3-第二次演进：引入本地缓存和分布式缓存"><a href="#3-3-第二次演进：引入本地缓存和分布式缓存" class="headerlink" title="3.3 第二次演进：引入本地缓存和分布式缓存"></a>3.3 第二次演进：引入本地缓存和分布式缓存</h3><img src="/2020/10/23/framework/framework-alibaba/3.webp" class="" title="引入本地缓存和分布式缓存"> <p>在Tomcat同服务器上或同JVM中增加本地缓存，并在外部增加分布式缓存，缓存热门商品信息或热门商品的html页面等。通过缓存能把绝大多数请求在读写数据库前拦截掉，大大降低数据库压力。</p><p>其中涉及的技术包括：使用memcached作为本地缓存，使用Redis作为分布式缓存，还会涉及缓存一致性、缓存穿透/击穿、缓存雪崩、热点数据集中失效等问题。</p><p>架构瓶颈：缓存抗住了大部分的访问请求，随着用户数的增长，并发压力主要落在单机的Tomcat上，响应逐渐变慢。</p><h3 id="3-4-第三次演进：引入反向代理实现负载均衡"><a href="#3-4-第三次演进：引入反向代理实现负载均衡" class="headerlink" title="3.4 第三次演进：引入反向代理实现负载均衡"></a>3.4 第三次演进：引入反向代理实现负载均衡</h3><img src="/2020/10/23/framework/framework-alibaba/4.webp" class="" title="引入反向代理实现负载均衡"> <p>在多台服务器上分别部署Tomcat，使用反向代理软件（Nginx）把请求均匀分发到每个Tomcat中。</p><p>此处假设Tomcat最多支持100个并发，Nginx最多支持50000个并发，那么理论上Nginx把请求分发到500个Tomcat上，就能抗住50000个并发。</p><p>其中涉及的技术包括：Nginx、HAProxy，两者都是工作在网络第七层的反向代理软件，主要支持http协议，还会涉及session共享、文件上传下载的问题。</p><p>架构瓶颈：反向代理使应用服务器可支持的并发量大大增加，但并发量的增长也意味着更多请求穿透到数据库，单机的数据库最终成为瓶颈。</p><h3 id="3-5-第四次演进：数据库读写分离"><a href="#3-5-第四次演进：数据库读写分离" class="headerlink" title="3.5 第四次演进：数据库读写分离"></a>3.5 第四次演进：数据库读写分离</h3><img src="/2020/10/23/framework/framework-alibaba/5.webp" class="" title="数据库读写分离"> <p>把数据库划分为读库和写库，读库可以有多个，通过同步机制把写库的数据同步到读库，对于需要查询最新写入数据场景，可通过在缓存中多写一份，通过缓存获得最新数据。</p><p>其中涉及的技术包括：Mycat，它是数据库中间件，可通过它来组织数据库的分离读写和分库分表，客户端通过它来访问下层数据库，还会涉及数据同步，数据一致性的问题。</p><p>架构瓶颈：业务逐渐变多，不同业务之间的访问量差距较大，不同业务直接竞争数据库，相互影响性能。</p><h3 id="3-6-第五次演进：数据库按业务分库"><a href="#3-6-第五次演进：数据库按业务分库" class="headerlink" title="3.6 第五次演进：数据库按业务分库"></a>3.6 第五次演进：数据库按业务分库</h3><img src="/2020/10/23/framework/framework-alibaba/6.webp" class="" title="数据库按业务分库"> <p>把不同业务的数据保存到不同的数据库中，使业务之间的资源竞争降低，对于访问量大的业务，可以部署更多的服务器来支撑。</p><p>这样同时导致跨业务的表无法直接做关联分析，需要通过其他途径来解决，但这不是本文讨论的重点，有兴趣的可以自行搜索解决方案。</p><p>架构瓶颈：随着用户数的增长，单机的写库会逐渐会达到性能瓶颈。</p><h3 id="3-7-第六次演进：把大表拆分为小表"><a href="#3-7-第六次演进：把大表拆分为小表" class="headerlink" title="3.7 第六次演进：把大表拆分为小表"></a>3.7 第六次演进：把大表拆分为小表</h3><img src="/2020/10/23/framework/framework-alibaba/7.webp" class="" title="把大表拆分为小表"> <p>比如针对评论数据，可按照商品ID进行hash，路由到对应的表中存储；</p><p>针对支付记录，可按照小时创建表，每个小时表继续拆分为小表，使用用户ID或记录编号来路由数据。</p><p>只要实时操作的表数据量足够小，请求能够足够均匀的分发到多台服务器上的小表，那数据库就能通过水平扩展的方式来提高性能。其中前面提到的Mycat也支持在大表拆分为小表情况下的访问控制。</p><p>这种做法显著的增加了数据库运维的难度，对DBA的要求较高。数据库设计到这种结构时，已经可以称为分布式数据库</p><p>但这只是一个逻辑的数据库整体，数据库里不同的组成部分是由不同的组件单独来实现的</p><p>如分库分表的管理和请求分发，由Mycat实现，SQL的解析由单机的数据库实现，读写分离可能由网关和消息队列来实现，查询结果的汇总可能由数据库接口层来实现等等</p><p>这种架构其实是MPP（大规模并行处理）架构的一类实现。</p><p>目前开源和商用都已经有不少MPP数据库，开源中比较流行的有Greenplum、TiDB、Postgresql XC、HAWQ等，商用的如南大通用的GBase、睿帆科技的雪球DB、华为的LibrA等等</p><p>不同的MPP数据库的侧重点也不一样，如TiDB更侧重于分布式OLTP场景，Greenplum更侧重于分布式OLAP场景</p><p>这些MPP数据库基本都提供了类似Postgresql、Oracle、MySQL那样的SQL标准支持能力，能把一个查询解析为分布式的执行计划分发到每台机器上并行执行，最终由数据库本身汇总数据进行返回</p><p>也提供了诸如权限管理、分库分表、事务、数据副本等能力，并且大多能够支持100个节点以上的集群，大大降低了数据库运维的成本，并且使数据库也能够实现水平扩展。</p><p>架构瓶颈：数据库和Tomcat都能够水平扩展，可支撑的并发大幅提高，随着用户数的增长，最终单机的Nginx会成为瓶颈。</p><h3 id="3-8-第七次演进：使用LVS或F5来使多个Nginx负载均衡"><a href="#3-8-第七次演进：使用LVS或F5来使多个Nginx负载均衡" class="headerlink" title="3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡"></a>3.8 第七次演进：使用LVS或F5来使多个Nginx负载均衡</h3><img src="/2020/10/23/framework/framework-alibaba/8.webp" class="" title="使用LVS或F5来使多个Nginx负载均衡"> <p>由于瓶颈在Nginx，因此无法通过两层的Nginx来实现多个Nginx的负载均衡。</p><p>图中的LVS和F5是工作在网络第四层的负载均衡解决方案，其中LVS是软件，运行在操作系统内核态，可对TCP请求或更高层级的网络协议进行转发，因此支持的协议更丰富，并且性能也远高于Nginx，可假设单机的LVS可支持几十万个并发的请求转发；</p><p>F5是一种负载均衡硬件，与LVS提供的能力类似，性能比LVS更高，但价格昂贵。</p><p>由于LVS是单机版的软件，若LVS所在服务器宕机则会导致整个后端系统都无法访问，因此需要有备用节点。</p><p>可使用keepalived软件模拟出虚拟IP，然后把虚拟IP绑定到多台LVS服务器上，浏览器访问虚拟IP时，会被路由器重定向到真实的LVS服务器</p><p>当主LVS服务器宕机时，keepalived软件会自动更新路由器中的路由表，把虚拟IP重定向到另外一台正常的LVS服务器，从而达到LVS服务器高可用的效果。</p><p>此处需要注意的是，上图中从Nginx层到Tomcat层这样画并不代表全部Nginx都转发请求到全部的Tomcat</p><p>在实际使用时，可能会是几个Nginx下面接一部分的Tomcat，这些Nginx之间通过keepalived实现高可用，其他的Nginx接另外的Tomcat，这样可接入的Tomcat数量就能成倍的增加。</p><p>架构瓶颈：由于LVS也是单机的，随着并发数增长到几十万时，LVS服务器最终会达到瓶颈，此时用户数达到千万甚至上亿级别，用户分布在不同的地区，与服务器机房距离不同，导致了访问的延迟会明显不同。</p><h3 id="3-9-第八次演进：通过DNS轮询实现机房间的负载均衡"><a href="#3-9-第八次演进：通过DNS轮询实现机房间的负载均衡" class="headerlink" title="3.9 第八次演进：通过DNS轮询实现机房间的负载均衡"></a>3.9 第八次演进：通过DNS轮询实现机房间的负载均衡</h3><img src="/2020/10/23/framework/framework-alibaba/9.webp" class="" title="通过DNS轮询实现机房间的负载均衡"> <p>在DNS服务器中可配置一个域名对应多个IP地址，每个IP地址对应到不同的机房里的虚拟IP。</p><p>当用户访问www.taobao.com时，DNS服务器会使用轮询策略或其他策略，来选择某个IP供用户访问。此方式能实现机房间的负载均衡</p><p>至此，系统可做到机房级别的水平扩展，千万级到亿级的并发量都可通过增加机房来解决，系统入口处的请求并发量不再是问题。</p><p>架构瓶颈：随着数据的丰富程度和业务的发展，检索、分析等需求越来越丰富，单单依靠数据库无法解决如此丰富的需求。</p><h3 id="3-10-第九次演进：引入NoSQL数据库和搜索引擎等技术"><a href="#3-10-第九次演进：引入NoSQL数据库和搜索引擎等技术" class="headerlink" title="3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术"></a>3.10 第九次演进：引入NoSQL数据库和搜索引擎等技术</h3><img src="/2020/10/23/framework/framework-alibaba/10.webp" class="" title="引入NoSQL数据库和搜索引擎等技术"> <p>当数据库中的数据多到一定规模时，数据库就不适用于复杂的查询了，往往只能满足普通查询的场景。</p><p>对于统计报表场景，在数据量大时不一定能跑出结果，而且在跑复杂查询时会导致其他查询变慢</p><p>对于全文检索、可变数据结构等场景，数据库天生不适用。因此需要针对特定的场景，引入合适的解决方案。</p><p>如对于海量文件存储，可通过分布式文件系统HDFS解决，对于key value类型的数据，可通过HBase和Redis等方案解决</p><p>对于全文检索场景，可通过搜索引擎如ElasticSearch解决，对于多维分析场景，可通过Kylin或Druid等方案解决。</p><p>当然，引入更多组件同时会提高系统的复杂度，不同的组件保存的数据需要同步，需要考虑一致性的问题，需要有更多的运维手段来管理这些组件等。</p><p>架构瓶颈：引入更多组件解决了丰富的需求，业务维度能够极大扩充，随之而来的是一个应用中包含了太多的业务代码，业务的升级迭代变得困难。</p><h3 id="3-11-第十次演进：大应用拆分为小应用"><a href="#3-11-第十次演进：大应用拆分为小应用" class="headerlink" title="3.11 第十次演进：大应用拆分为小应用"></a>3.11 第十次演进：大应用拆分为小应用</h3><img src="/2020/10/23/framework/framework-alibaba/11.webp" class="" title="大应用拆分为小应用"> <p>按照业务板块来划分应用代码，使单个应用的职责更清晰，相互之间可以做到独立升级迭代。这时候应用之间可能会涉及到一些公共配置，可以通过分布式配置中心Zookeeper来解决。</p><p>架构瓶颈：不同应用之间存在共用的模块，由应用单独管理会导致相同代码存在多份，导致公共功能升级时全部应用代码都要跟着升级。</p><h3 id="3-12-第十一次演进：复用的功能抽离成微服务"><a href="#3-12-第十一次演进：复用的功能抽离成微服务" class="headerlink" title="3.12 第十一次演进：复用的功能抽离成微服务"></a>3.12 第十一次演进：复用的功能抽离成微服务</h3><img src="/2020/10/23/framework/framework-alibaba/12.webp" class="" title="复用的功能抽离成微服务"> <p>如用户管理、订单、支付、鉴权等功能在多个应用中都存在，那么可以把这些功能的代码单独抽取出来形成一个单独的服务来管理</p><p>这样的服务就是所谓的微服务，应用和服务之间通过HTTP、TCP或RPC请求等多种方式来访问公共服务，每个单独的服务都可以由单独的团队来管理。</p><p>此外，可以通过Dubbo、SpringCloud等框架实现服务治理、限流、熔断、降级等功能，提高服务的稳定性和可用性。</p><p>架构瓶颈：不同服务的接口访问方式不同，应用代码需要适配多种访问方式才能使用服务，此外，应用访问服务，服务之间也可能相互访问，调用链将会变得非常复杂，逻辑变得混乱。</p><h3 id="3-13-第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"><a href="#3-13-第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异" class="headerlink" title="3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异"></a>3.13 第十二次演进：引入企业服务总线ESB屏蔽服务接口的访问差异</h3><img src="/2020/10/23/framework/framework-alibaba/13.webp" class="" title="引入企业服务总线ESB屏蔽服务接口的访问差异"> <p>通过ESB统一进行访问协议转换，应用统一通过ESB来访问后端服务，服务与服务之间也通过ESB来相互调用，以此降低系统的耦合程度。</p><p>这种单个应用拆分为多个应用，公共服务单独抽取出来来管理，并使用企业消息总线来解除服务之间耦合问题的架构，就是所谓的SOA（面向服务）架构，这种架构与微服务架构容易混淆，因为表现形式十分相似。</p><p>个人理解，微服务架构更多是指把系统里的公共服务抽取出来单独运维管理的思想，而SOA架构则是指一种拆分服务并使服务接口访问变得统一的架构思想，SOA架构中包含了微服务的思想。</p><p>架构瓶颈：业务不断发展，应用和服务都会不断变多，应用和服务的部署变得复杂，同一台服务器上部署多个服务还要解决运行环境冲突的问题</p><p>此外，对于如大促这类需要动态扩缩容的场景，需要水平扩展服务的性能，就需要在新增的服务上准备运行环境，部署服务等，运维将变得十分困难。</p><h3 id="3-14-第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"><a href="#3-14-第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理" class="headerlink" title="3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理"></a>3.14 第十三次演进：引入容器化技术实现运行环境隔离与动态服务管理</h3><img src="/2020/10/23/framework/framework-alibaba/14.webp" class="" title="引入容器化技术实现运行环境隔离与动态服务管理"> <p>目前最流行的容器化技术是Docker，最流行的容器管理服务是Kubernetes(K8S)，应用/服务可以打包为Docker镜像，通过K8S来动态分发和部署镜像。</p><p>Docker镜像可理解为一个能运行你的应用/服务的最小的操作系统，里面放着应用/服务的运行代码，运行环境根据实际的需要设置好。</p><p>把整个“操作系统”打包为一个镜像后，就可以分发到需要部署相关服务的机器上，直接启动Docker镜像就可以把服务起起来，使服务的部署和运维变得简单。</p><p>在大促的之前，可以在现有的机器集群上划分出服务器来启动Docker镜像，增强服务的性能</p><p>大促过后就可以关闭镜像，对机器上的其他服务不造成影响（在第18节之前，服务运行在新增机器上需要修改系统配置来适配服务，这会导致机器上其他服务需要的运行环境被破坏）。</p><p>架构瓶颈：使用容器化技术后服务动态扩缩容问题得以解决，但是机器还是需要公司自身来管理，在非大促的时候，还是需要闲置着大量的机器资源来应对大促，机器自身成本和运维成本都极高，资源利用率低。</p><h3 id="3-15-第十四次演进：以云平台承载系统"><a href="#3-15-第十四次演进：以云平台承载系统" class="headerlink" title="3.15 第十四次演进：以云平台承载系统"></a>3.15 第十四次演进：以云平台承载系统</h3><img src="/2020/10/23/framework/framework-alibaba/15.webp" class="" title="以云平台承载系统"> <p>系统可部署到公有云上，利用公有云的海量机器资源，解决动态硬件资源的问题</p><p>在大促的时间段里，在云平台中临时申请更多的资源，结合Docker和K8S来快速部署服务，在大促结束后释放资源，真正做到按需付费，资源利用率大大提高，同时大大降低了运维成本。</p><p>所谓的云平台，就是把海量机器资源，通过统一的资源管理，抽象为一个资源整体</p><p>在云平台上可按需动态申请硬件资源（如CPU、内存、网络等），并且之上提供通用的操作系统，提供常用的技术组件（如Hadoop技术栈，MPP数据库等）供用户使用，甚至提供开发好的应用</p><p>用户不需要关心应用内部使用了什么技术，就能够解决需求（如音视频转码服务、邮件服务、个人博客等）。</p><p>在云平台中会涉及如下几个概念：</p><p>IaaS：基础设施即服务。对应于上面所说的机器资源统一为资源整体，可动态申请硬件资源的层面；</p><p>PaaS：平台即服务。对应于上面所说的提供常用的技术组件方便系统的开发和维护；</p><p>SaaS：软件即服务。对应于上面所说的提供开发好的应用或服务，按功能或性能要求付费。</p><p>至此：以上所提到的从高并发访问问题，到服务的架构和系统实施的层面都有了各自的解决方案。</p><p>但同时也应该意识到，在上面的介绍中，其实是有意忽略了诸如跨机房数据同步、分布式事务实现等等的实际问题，这些问题以后有机会再拿出来单独讨论。</p><h2 id="4、架构设计总结"><a href="#4、架构设计总结" class="headerlink" title="4、架构设计总结"></a>4、架构设计总结</h2><h3 id="1）架构的调整是否必须按照上述演变路径进行？"><a href="#1）架构的调整是否必须按照上述演变路径进行？" class="headerlink" title="1）架构的调整是否必须按照上述演变路径进行？"></a>1）架构的调整是否必须按照上述演变路径进行？</h3><p>不是的，以上所说的架构演变顺序只是针对某个侧面进行单独的改进</p><p>在实际场景中，可能同一时间会有几个问题需要解决，或者可能先达到瓶颈的是另外的方面，这时候就应该按照实际问题实际解决。</p><p>如在政府类的并发量可能不大，但业务可能很丰富的场景，高并发就不是重点解决的问题，此时优先需要的可能会是丰富需求的解决方案。</p><h3 id="2）对于将要实施的系统，架构应该设计到什么程度？"><a href="#2）对于将要实施的系统，架构应该设计到什么程度？" class="headerlink" title="2）对于将要实施的系统，架构应该设计到什么程度？"></a>2）对于将要实施的系统，架构应该设计到什么程度？</h3><p>对于单次实施并且性能指标明确的系统，架构设计到能够支持系统的性能指标要求就足够了，但要留有扩展架构的接口以便不备之需。</p><p>对于不断发展的系统，如电商平台，应设计到能满足下一阶段用户量和性能指标要求的程度，并根据业务的增长不断的迭代升级架构，以支持更高的并发和更丰富的业务。</p><h3 id="3）服务端架构和大数据架构有什么区别？"><a href="#3）服务端架构和大数据架构有什么区别？" class="headerlink" title="3）服务端架构和大数据架构有什么区别？"></a>3）服务端架构和大数据架构有什么区别？</h3><p>所谓的“大数据”其实是海量数据采集清洗转换、数据存储、数据分析、数据服务等场景解决方案的一个统称，在每一个场景都包含了多种可选的技术</p><p>如数据采集有Flume、Sqoop、Kettle等，数据存储有分布式文件系统HDFS、FastDFS，NoSQL数据库HBase、MongoDB等，数据分析有Spark技术栈、机器学习算法等。</p><p>总的来说大数据架构就是根据业务的需求，整合各种大数据组件组合而成的架构，一般会提供分布式存储、分布式计算、多维分析、数据仓库、机器学习算法等能力。</p><p>而服务端架构更多指的是应用组织层面的架构，底层能力往往是由大数据架构来提供。</p><h3 id="4）有没有一些架构设计的原则？"><a href="#4）有没有一些架构设计的原则？" class="headerlink" title="4）有没有一些架构设计的原则？"></a>4）有没有一些架构设计的原则？</h3><pre><code>- N+1设计：系统中的每个组件都应做到没有单点故障；- 回滚设计：确保系统可以向前兼容，在系统升级时应能有办法回滚版本；- 禁用设计：应该提供控制具体功能是否可用的配置，在系统出现故障时能够快速下线功能；- 监控设计：在设计阶段就要考虑监控的手段；- 多活数据中心设计：若系统需要极高的高可用，应考虑在多地实施数据中心进行多活，至少在一个机房断电的情况下系统依然可用；- 采用成熟的技术：刚开发的或开源的技术往往存在很多隐藏的bug，出了问题没有商业支持可能会是一个灾难；- 资源隔离设计：应避免单一业务占用全部资源；- 架构应能水平扩展：系统只有做到能水平扩展，才能有效避免瓶颈问题；- 非核心则购买：非核心功能若需要占用大量的研发资源才能解决，则考虑购买成熟的产品；- 使用商用硬件：商用硬件能有效降低硬件故障的机率；- 快速迭代：系统应该快速开发小功能模块，尽快上线进行验证，早日发现问题大大降低系统交付的风险；- 无状态设计：服务接口应该做成无状态的，当前接口的访问不依赖于接口上次访问的状态。</code></pre>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程&lt;/p&gt;
&lt;h2 id=&quot;1、-概述&quot;&gt;&lt;a href=&quot;#1、-概述&quot; class=&quot;headerlink&quot; title=&quot;1、 概述&quot;&gt;&lt;/a&gt;1、 概述&lt;/h2&gt;&lt;p&gt;本文以淘宝作为例子，介绍从一百个并发到千万级并发情况下服务端的架构的演进过程，同时列举出每个演进阶段会遇到的相关技术，让大家对架构的演进有一个整体的认知，文章最后汇总了一些架构设计的原则。&lt;/p&gt;
&lt;h2 id=&quot;2、基本概念&quot;&gt;&lt;a href=&quot;#2、基本概念&quot; class=&quot;headerlink&quot; title=&quot;2、基本概念&quot;&gt;&lt;/a&gt;2、基本概念&lt;/h2&gt;&lt;p&gt;在介绍架构之前，为了避免部分读者对架构设计中的一些概念不了解，下面对几个最基础的概念进行介绍。&lt;/p&gt;
&lt;h3 id=&quot;1）什么是分布式？&quot;&gt;&lt;a href=&quot;#1）什么是分布式？&quot; class=&quot;headerlink&quot; title=&quot;1）什么是分布式？&quot;&gt;&lt;/a&gt;1）什么是分布式？&lt;/h3&gt;&lt;p&gt;系统中的多个模块在不同服务器上部署，即可称为分布式系统，如Tomcat和数据库分别部署在不同的服务器上，或两个相同功能的Tomcat分别部署在不同服务器上。&lt;/p&gt;
&lt;h3 id=&quot;2）什么是高可用？&quot;&gt;&lt;a href=&quot;#2）什么是高可用？&quot; class=&quot;headerlink&quot; title=&quot;2）什么是高可用？&quot;&gt;&lt;/a&gt;2）什么是高可用？&lt;/h3&gt;&lt;p&gt;系统中部分节点失效时，其他节点能够接替它继续提供服务，则可认为系统具有高可用性。&lt;/p&gt;
&lt;h3 id=&quot;3）什么是集群？&quot;&gt;&lt;a href=&quot;#3）什么是集群？&quot; class=&quot;headerlink&quot; title=&quot;3）什么是集群？&quot;&gt;&lt;/a&gt;3）什么是集群？&lt;/h3&gt;&lt;p&gt;一个特定领域的软件部署在多台服务器上并作为一个整体提供一类服务，这个整体称为集群。&lt;br&gt;如Zookeeper中的Master和Slave分别部署在多台服务器上，共同组成一个整体提供集中配置服务。&lt;br&gt;在常见的集群中，客户端往往能够连接任意一个节点获得服务，并且当集群中一个节点掉线时，其他节点往往能够自动的接替它继续提供服务，这时候说明集群具有高可用性。&lt;/p&gt;
&lt;h3 id=&quot;4）什么是负载均衡？&quot;&gt;&lt;a href=&quot;#4）什么是负载均衡？&quot; class=&quot;headerlink&quot; title=&quot;4）什么是负载均衡？&quot;&gt;&lt;/a&gt;4）什么是负载均衡？&lt;/h3&gt;&lt;p&gt;请求发送到系统时，通过某些方式把请求均匀分发到多个节点上，使系统中每个节点能够均匀的处理请求负载，则可认为系统是负载均衡的。&lt;/p&gt;
&lt;h3 id=&quot;5）什么是正向代理和反向代理？&quot;&gt;&lt;a href=&quot;#5）什么是正向代理和反向代理？&quot; class=&quot;headerlink&quot; title=&quot;5）什么是正向代理和反向代理？&quot;&gt;&lt;/a&gt;5）什么是正向代理和反向代理？&lt;/h3&gt;&lt;p&gt;系统内部要访问外部网络时，统一通过一个代理服务器把请求转发出去，在外部网络看来就是代理服务器发起的访问，此时代理服务器实现的是正向代理；&lt;br&gt;当外部请求进入系统时，代理服务器把该请求转发到系统中的某台服务器上，对外部请求来说，与之交互的只有代理服务器，此时代理服务器实现的是反向代理。&lt;br&gt;简单来说，正向代理是代理服务器代替系统内部来访问外部网络的过程，反向代理是外部请求访问系统时通过代理服务器转发到内部服务器的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="架构" scheme="http://blog.rcant.com/categories/%E6%9E%B6%E6%9E%84/"/>
    
    
    <category term="架构" scheme="http://blog.rcant.com/tags/%E6%9E%B6%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 控制台操作</title>
    <link href="http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-console/"/>
    <id>http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-console/</id>
    <published>2020-10-23T13:39:17.000Z</published>
    <updated>2023-01-06T09:38:48.462Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ 控制台操作</p><p>对应的RabbitMQ操作</p><h5 id="RabbitMQ-控制台操作"><a href="#RabbitMQ-控制台操作" class="headerlink" title="RabbitMQ 控制台操作"></a>RabbitMQ 控制台操作</h5><ol><li>添加guest用户</li></ol><p>guest用户设置密码为 guest</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-adduser1.png" class="" title="添加guest"> <img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-adduser2.png" class="" title="添加guest2"> <ol><li>添加 vhost -&gt; frexport</li></ol><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addvhost1.png" class="" title="添加vhost"> <p>设置VHost权限，添加guest用户权限</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost1.png" class="" title="设置权限"> <p>设置后如下</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost2.png" class="" title="添加vhost"> <p>回到User界面</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost3.png" class="" title="添加vhost"> <ol><li>添加Quene 队列 hello</li></ol><p>我们使用 frexport 虚拟主机创建一个队列 hello</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addquene1.png" class="" title="添加队列1"> <p>添加后</p><img src="/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addquene2.png" class="" title="添加队列2"> <span id="more"></span><h2 id="RabbitMQ-基础知识"><a href="#RabbitMQ-基础知识" class="headerlink" title="RabbitMQ 基础知识"></a>RabbitMQ 基础知识</h2><ul><li><a href="/2020/10/23/mq/rabbitmq-base-use/" title="RabbitMQ 基础知识">RabbitMQ 基础知识</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-install/" title="RabbitMQ 安装">RabbitMQ 安装</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-exchange/" title="RabbitMQ 交换机">RabbitMQ 交换机</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-console/" title="RabbitMQ 控制台">RabbitMQ 控制台</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-messagedispatch/" title="RabbitMQ 消息分发">RabbitMQ 消息分发</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ 控制台操作&lt;/p&gt;
&lt;p&gt;对应的RabbitMQ操作&lt;/p&gt;
&lt;h5 id=&quot;RabbitMQ-控制台操作&quot;&gt;&lt;a href=&quot;#RabbitMQ-控制台操作&quot; class=&quot;headerlink&quot; title=&quot;RabbitMQ 控制台操作&quot;&gt;&lt;/a&gt;RabbitMQ 控制台操作&lt;/h5&gt;&lt;ol&gt;
&lt;li&gt;添加guest用户&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;guest用户设置密码为 guest&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-adduser1.png&quot; class=&quot;&quot; title=&quot;添加guest&quot;&gt; 
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-adduser2.png&quot; class=&quot;&quot; title=&quot;添加guest2&quot;&gt; 
&lt;ol&gt;
&lt;li&gt;添加 vhost -&amp;gt; frexport&lt;/li&gt;
&lt;/ol&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addvhost1.png&quot; class=&quot;&quot; title=&quot;添加vhost&quot;&gt; 
&lt;p&gt;设置VHost权限，添加guest用户权限&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost1.png&quot; class=&quot;&quot; title=&quot;设置权限&quot;&gt; 
&lt;p&gt;设置后如下&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost2.png&quot; class=&quot;&quot; title=&quot;添加vhost&quot;&gt; 
&lt;p&gt;回到User界面&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-setvhost3.png&quot; class=&quot;&quot; title=&quot;添加vhost&quot;&gt; 
&lt;ol&gt;
&lt;li&gt;添加Quene 队列 hello&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;我们使用 frexport 虚拟主机创建一个队列 hello&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addquene1.png&quot; class=&quot;&quot; title=&quot;添加队列1&quot;&gt; 
&lt;p&gt;添加后&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-console/rabbitmq-addquene2.png&quot; class=&quot;&quot; title=&quot;添加队列2&quot;&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ Exchange 概念</title>
    <link href="http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-exchange/"/>
    <id>http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-exchange/</id>
    <published>2020-10-23T13:39:17.000Z</published>
    <updated>2023-01-06T09:38:53.500Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ 交换机概念</p><h3 id="Exchange-交换机"><a href="#Exchange-交换机" class="headerlink" title="Exchange 交换机"></a>Exchange 交换机</h3><p>RabbitMQ 中的消息 不是直接发送到Queue中的，中间有一个Exchange 做消息分发。<br>producer甚至都不知道消息发送到哪个队列中去。因此,当Exchange收到message时，必须知道如何准备分发消息。<br>具体是append 到一定规则的queue,还是append到多个queue中，还是被丢弃？这些都是通过 exchange的类型定义的。<br>|type|作用|创建vhost时默认创建的exchange的名称|<br>|-|-|-|<br>|direct|路由模式|(Empty string) and amq.direct|<br>|fanout|发布/订阅模式|amq.fanout|<br>|Topic|主题模式|amq.topic|<br>|headers||amq.match (and amq.headers in RabbitMQ)|</p><img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-all.png" class="" title="DirectExchange"> <h4 id="一-Direct-Exchange"><a href="#一-Direct-Exchange" class="headerlink" title="一:Direct Exchange"></a>一:Direct Exchange</h4><p>它处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。 </p><img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-direct.png" class="" title="DirectExchange"> <img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-direct1.png" class="" title="DirectExchange"> <p>直接交换通常用于:</p><ul><li>以循环方式在多个 workers（同一应用程序的实例）之间分配任务。当这样做时，消息在消费者之间而不是在队列之间是负载平衡的。</li></ul><span id="more"></span><h4 id="二、Fanout-Exchange"><a href="#二、Fanout-Exchange" class="headerlink" title="二、Fanout Exchange"></a>二、Fanout Exchange</h4><p>它不处理路由键。你只需要简单的将队列绑定到交换机上。一个发送到交换机的消息都会被转发到与该交换机绑定的所有队列上。很像子网广播，每台子网内的主机都获得了一份复制的消息。Fanout交换机转发消息是最快的。 </p><img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-fanout.png" class="" title="FanoutExchange"> <img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-fanout1.png" class="" title="FanoutExchange"> <p>如果N个队列绑定到 Fanout Exchange ，则当向该交换机发布新消息时，将向所有N个队列传递消息的副本。 Fanout Exchange 是广播消息路由的理想选择。</p><p>Fanout Exchange 向每个绑定到它的队列传递消息副本，适用场景如下：</p><ul><li>大型多人在线（MMO）游戏可用于排行榜更新或其他全球性事件。</li><li>体育新闻网站可以使用 Fanout Exchange 来实时更新移动客户端的评分更新。</li><li>分布式系统可以广播各种状态和配置更新</li></ul><h4 id="三、Topic-Exchange"><a href="#三、Topic-Exchange" class="headerlink" title="三、Topic Exchange"></a>三、Topic Exchange</h4><p>它将路由键和某模式进行匹配。此时队列需要绑定要一个模式上。符号“#”匹配一个或多个词，符号“<em>”匹配不多不少一个词。因此“audit.#”能够匹配到 “audit.irs.corporate”，但是“audit.</em>” 只会匹配到“audit.irs”。我在RedHat的朋友做了一张不错的图，来表明topic交换机是如何工作的：</p><img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-topic.png" class="" title="TopicExchange"> <img src="/2020/10/23/mq/rabbitmq-base-exchange/exchange-topic1.png" class="" title="TopicExchange"> <p>每当问题涉及多个消费者/应用程序，它们有选择地选择它们想要接收哪种类型的消息时，应该考虑使用 Topic Exchange 。</p><p>示例用途：</p><ul><li>分配与特定地理位置相关的数据，例如销售点</li><li>后台任务处理由多个工人完成，每个任务都能够处理特定的任务集。</li><li>股票价格的更新（以及其他类型的金融数据的更新）</li><li>涉及分类或标记的新闻更新（例如，仅针对特定的运动或团队）</li><li>云中不同类型服务的编排</li><li>分布式体系结构/ OS特定的软件构建或打包，其中每个构建器只能处理一个体系结构或操作系统。</li></ul><h4 id="四、Headers-exchange"><a href="#四、Headers-exchange" class="headerlink" title="四、Headers exchange"></a>四、Headers exchange</h4><p>A headers exchange is designed to for routing on multiple attributes that are more easily expressed as message headers than a routing key. Headers exchanges ignore the routing key attribute. Instead, the attributes used for routing are taken from the headers attribute. A message is considered matching if the value of the header equals the value specified upon binding.</p><p>　　It is possible to bind a queue to a headers exchange using more than one header for matching. In this case, the broker needs one more piece of information from the application developer, namely, should it consider messages with any of the headers matching, or all of them? This is what the “x-match” binding argument is for. When the “x-match” argument is set to “any”, just one matching header value is sufficient. Alternatively, setting “x-match” to “all” mandates that all the values must match.</p><p>　　Headers exchanges can be looked upon as “direct exchanges on steroids”. Because they route based on header values, they can be used as direct exchanges where the routing key does not have to be a string; it could be an integer or a hash (dictionary) for example.</p><p>不处理路由键。而是根据发送的消息内容中的headers属性进行匹配。在绑定Queue与Exchange时指定一组键值对；当消息发送到RabbitMQ时会取到该消息的headers与Exchange绑定时指定的键值对进行匹配；如果完全匹配则消息会路由到该队列，否则不会路由到该队列。headers属性是一个键值对，可以是Hashtable，键值对的值可以是任何类型。而fanout，direct，topic 的路由键都需要要字符串形式的。</p><p>匹配规则x-match有下列两种类型：</p><p>x-match = all ：表示所有的键值对都匹配才能接受到消息</p><p>x-match = any ：表示只要有键值对匹配就能接受到消息</p><h4 id="五、Default-Exchange"><a href="#五、Default-Exchange" class="headerlink" title="五、Default Exchange"></a>五、Default Exchange</h4><p>它是一种特别的exchange，当你手动创建一个队列时，后台会自动将这个队列绑定到一个名称为空的Direct 类型交换机上，绑定路由名称与队列名称相同。有了这个默认的交换机和绑定，我们就可以像其他轻量级的队列，如Redis那样，直接操作队列来处理消息。不过只是看起来是，实际上在RabbitMQ里直接操作是不可能的。消息始终都是先发送到交换机，由交换级经过路由传送给队列，消费者再从队列中获取消息的。不过由于这个默认交换机和路由的关系，使我们只关心队列这一层即可，这个比较适合做一些简单的应用，毕竟没有发挥RabbitMQ的最大功能，如果都用这种方式去使用的话就真是杀鸡用宰牛刀了。</p><h2 id="RabbitMQ-基础知识"><a href="#RabbitMQ-基础知识" class="headerlink" title="RabbitMQ 基础知识"></a>RabbitMQ 基础知识</h2><ul><li><a href="/2020/10/23/mq/rabbitmq-base-use/" title="RabbitMQ 基础知识">RabbitMQ 基础知识</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-install/" title="RabbitMQ 安装">RabbitMQ 安装</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-exchange/" title="RabbitMQ 交换机">RabbitMQ 交换机</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-console/" title="RabbitMQ 控制台">RabbitMQ 控制台</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-messagedispatch/" title="RabbitMQ 消息分发">RabbitMQ 消息分发</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ 交换机概念&lt;/p&gt;
&lt;h3 id=&quot;Exchange-交换机&quot;&gt;&lt;a href=&quot;#Exchange-交换机&quot; class=&quot;headerlink&quot; title=&quot;Exchange 交换机&quot;&gt;&lt;/a&gt;Exchange 交换机&lt;/h3&gt;&lt;p&gt;RabbitMQ 中的消息 不是直接发送到Queue中的，中间有一个Exchange 做消息分发。&lt;br&gt;producer甚至都不知道消息发送到哪个队列中去。因此,当Exchange收到message时，必须知道如何准备分发消息。&lt;br&gt;具体是append 到一定规则的queue,还是append到多个queue中，还是被丢弃？这些都是通过 exchange的类型定义的。&lt;br&gt;|type|作用|创建vhost时默认创建的exchange的名称|&lt;br&gt;|-|-|-|&lt;br&gt;|direct|路由模式|(Empty string) and amq.direct|&lt;br&gt;|fanout|发布/订阅模式|amq.fanout|&lt;br&gt;|Topic|主题模式|amq.topic|&lt;br&gt;|headers||amq.match (and amq.headers in RabbitMQ)|&lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-exchange/exchange-all.png&quot; class=&quot;&quot; title=&quot;DirectExchange&quot;&gt; 
&lt;h4 id=&quot;一-Direct-Exchange&quot;&gt;&lt;a href=&quot;#一-Direct-Exchange&quot; class=&quot;headerlink&quot; title=&quot;一:Direct Exchange&quot;&gt;&lt;/a&gt;一:Direct Exchange&lt;/h4&gt;&lt;p&gt;它处理路由键。需要将一个队列绑定到交换机上，要求该消息与一个特定的路由键完全匹配。这是一个完整的匹配。如果一个队列绑定到该交换机上要求路由键 “dog”，则只有被标记为“dog”的消息才被转发，不会转发dog.puppy，也不会转发dog.guard，只会转发dog。 &lt;/p&gt;
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-exchange/exchange-direct.png&quot; class=&quot;&quot; title=&quot;DirectExchange&quot;&gt; 
&lt;img src=&quot;/2020/10/23/mq/rabbitmq-base-exchange/exchange-direct1.png&quot; class=&quot;&quot; title=&quot;DirectExchange&quot;&gt; 
&lt;p&gt;直接交换通常用于:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;以循环方式在多个 workers（同一应用程序的实例）之间分配任务。当这样做时，消息在消费者之间而不是在队列之间是负载平衡的。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 安装</title>
    <link href="http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-install/"/>
    <id>http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-install/</id>
    <published>2020-10-23T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:01.493Z</updated>
    
    <content type="html"><![CDATA[<p>RabbitMQ 安装</p><p><a href="http://www.rabbitmq.com/">RabbitMQ官网</a></p><h2 id="安装-RabbitMQ"><a href="#安装-RabbitMQ" class="headerlink" title="安装 RabbitMQ"></a>安装 RabbitMQ</h2><p>docker需要先装好</p><p>使用 <strong>docker-compose</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost ~]# mkdir rabbitmq</span><br><span class="line">[root@localhost ~]# cd rabbitmq/</span><br><span class="line">[root@localhost rabbitmq]# mkdir data</span><br><span class="line">[root@localhost rabbitmq]# mkdir log</span><br><span class="line">[root@localhost rabbitmq]# vi docker-compose.yml</span><br></pre></td></tr></table></figure><p>docker-compose.yml 内容</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">version: &#x27;2&#x27;</span><br><span class="line">services:</span><br><span class="line">    rabbitmq:</span><br><span class="line">       hostname: rabbitmq</span><br><span class="line">       environment:</span><br><span class="line">         RABBITMQ_DEFAULT_VHOST: &quot;xxx&quot;</span><br><span class="line">         RABBITMQ_DEFAULT_USER: &quot;admin&quot;</span><br><span class="line">         RABBITMQ_DEFAULT_PASS: &quot;admin&quot;</span><br><span class="line">       image: &quot;rabbitmq:3-management&quot;</span><br><span class="line">       restart: always</span><br><span class="line">       volumes:</span><br><span class="line">         - &quot;./data:/var/lib/rabbitmq&quot;</span><br><span class="line">         - &quot;./log:/var/log/rabbitmq/log&quot;</span><br><span class="line">       ports:</span><br><span class="line">         - &quot;4369:4369&quot;</span><br><span class="line">         - &quot;5672:5672&quot;</span><br><span class="line">         - &quot;15672:15672&quot;</span><br><span class="line">         - &quot;25672:25672&quot;</span><br></pre></td></tr></table></figure><span id="more"></span><p>启动 <strong>docker</strong> 容器<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose up -d</span><br></pre></td></tr></table></figure></p><ul><li>5672:默认的客户端连接的端口</li><li>15672：默认的web管理界面的端口</li></ul><p>访问15672端口出现下面界面代表RabbitMQ安装成功</p><img src="/2020/10/23/mq/rabbitmq-base-install/rabbit-startup.png" class="" title="RabbitMQ启动"> <p>账号密码为 </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">RABBITMQ_DEFAULT_USER: &quot;admin&quot;</span><br><span class="line">RABBITMQ_DEFAULT_PASS: &quot;admin&quot;</span><br></pre></td></tr></table></figure><img src="/2020/10/23/mq/rabbitmq-base-install/rabbit-overview.png" class="" title="RabbitMQ概述"> <h2 id="RabbitMQ-基础知识"><a href="#RabbitMQ-基础知识" class="headerlink" title="RabbitMQ 基础知识"></a>RabbitMQ 基础知识</h2><ul><li><a href="/2020/10/23/mq/rabbitmq-base-use/" title="RabbitMQ 基础知识">RabbitMQ 基础知识</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-install/" title="RabbitMQ 安装">RabbitMQ 安装</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-exchange/" title="RabbitMQ 交换机">RabbitMQ 交换机</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-console/" title="RabbitMQ 控制台">RabbitMQ 控制台</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-messagedispatch/" title="RabbitMQ 消息分发">RabbitMQ 消息分发</a>  </li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;RabbitMQ 安装&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://www.rabbitmq.com/&quot;&gt;RabbitMQ官网&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;安装-RabbitMQ&quot;&gt;&lt;a href=&quot;#安装-RabbitMQ&quot; class=&quot;headerlink&quot; title=&quot;安装 RabbitMQ&quot;&gt;&lt;/a&gt;安装 RabbitMQ&lt;/h2&gt;&lt;p&gt;docker需要先装好&lt;/p&gt;
&lt;p&gt;使用 &lt;strong&gt;docker-compose&lt;/strong&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# mkdir rabbitmq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost ~]# cd rabbitmq/&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost rabbitmq]# mkdir data&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost rabbitmq]# mkdir log&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[root@localhost rabbitmq]# vi docker-compose.yml&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;docker-compose.yml 内容&lt;/p&gt;
&lt;figure class=&quot;highlight plaintext&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;18&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;version: &amp;#x27;2&amp;#x27;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;services:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    rabbitmq:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       hostname: rabbitmq&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       environment:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         RABBITMQ_DEFAULT_VHOST: &amp;quot;xxx&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         RABBITMQ_DEFAULT_USER: &amp;quot;admin&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         RABBITMQ_DEFAULT_PASS: &amp;quot;admin&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       image: &amp;quot;rabbitmq:3-management&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       restart: always&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       volumes:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;./data:/var/lib/rabbitmq&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;./log:/var/log/rabbitmq/log&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;       ports:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;4369:4369&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;5672:5672&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;15672:15672&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         - &amp;quot;25672:25672&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 任务分发</title>
    <link href="http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-messagedispatch/"/>
    <id>http://blog.rcant.com/2020/10/23/mq/rabbitmq-base-messagedispatch/</id>
    <published>2020-10-23T13:39:17.000Z</published>
    <updated>2023-01-06T09:39:07.546Z</updated>
    
    <content type="html"><![CDATA[<p>任务分发</p><h2 id="任务分发机制"><a href="#任务分发机制" class="headerlink" title="任务分发机制"></a>任务分发机制</h2><p>使用任务队列的优点之一是可以轻易的进行一步工作。</p><p>如果我们现在积压了很多工作，可以通过增加消费者来解决这个问题，使得系统伸缩性更加容易</p><h2 id="Round-robin（轮询分发）"><a href="#Round-robin（轮询分发）" class="headerlink" title="Round-robin（轮询分发）"></a>Round-robin（轮询分发）</h2><p>发布者 RabbitMQ 发送几条消息<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using System;</span><br><span class="line">using System.Collections.Generic;</span><br><span class="line">using System.Text;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace WorkMQProduct</span><br><span class="line">&#123;</span><br><span class="line">    class NewTask</span><br><span class="line">    &#123;</span><br><span class="line">        static string QueueName = &quot;task_queue&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory()</span><br><span class="line">            &#123;</span><br><span class="line">                HostName = &quot;localhost&quot;,</span><br><span class="line">                VirtualHost = &quot;frexport&quot;,</span><br><span class="line">                UserName = &quot;guest&quot;,</span><br><span class="line">                Password = &quot;guest&quot;</span><br><span class="line">            &#125;;</span><br><span class="line">            List&lt;int&gt; taskMessages = new List&lt;int&gt; &#123; 2, 7, 2, 6, 5, 2, 2, 3 &#125;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            using (var channel = connection.CreateModel())</span><br><span class="line">            &#123;</span><br><span class="line">                channel.QueueDeclare(queue: QueueName,</span><br><span class="line">                                     durable: true,</span><br><span class="line">                                     exclusive: false,</span><br><span class="line">                                     autoDelete: false,</span><br><span class="line">                                     arguments: null);</span><br><span class="line"></span><br><span class="line">                var properties = channel.CreateBasicProperties();</span><br><span class="line">                properties.SetPersistent(true);</span><br><span class="line"></span><br><span class="line">                for (int i = 0; i &lt; 8; i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    string message = taskMessages[i] + &quot;&quot;;</span><br><span class="line">                    var body = Encoding.UTF8.GetBytes(message);</span><br><span class="line"></span><br><span class="line">                    properties.CorrelationId = i + &quot;&quot;;</span><br><span class="line">                    channel.BasicPublish(exchange: &quot;&quot;,</span><br><span class="line">                                     routingKey: QueueName,</span><br><span class="line">                                     basicProperties: properties,</span><br><span class="line">                                     body: body);</span><br><span class="line">                    Console.WriteLine(&quot; [x] &#123;0&#125; Sent &#123;1&#125;&quot;, properties.CorrelationId, message);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">            Console.ReadLine();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&lt;!--more--&gt;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p><p>消费者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><span class="line">using RabbitMQ.Client;</span><br><span class="line">using RabbitMQ.Client.Events;</span><br><span class="line">using System;</span><br><span class="line">using System.Threading;</span><br><span class="line"></span><br><span class="line">namespace WorkMQConsumer</span><br><span class="line">&#123;</span><br><span class="line">    class Worker</span><br><span class="line">    &#123;</span><br><span class="line">        static string QueueName = &quot;task_queue&quot;;</span><br><span class="line">        static void Main(string[] args)</span><br><span class="line">        &#123;</span><br><span class="line">            var factory = new ConnectionFactory() &#123; &#125;;</span><br><span class="line">            factory.HostName = &quot;localhost&quot;;</span><br><span class="line">            factory.VirtualHost = &quot;frexport&quot;;</span><br><span class="line">            factory.UserName = &quot;guest&quot;;</span><br><span class="line">            factory.Password = &quot;guest&quot;;</span><br><span class="line"></span><br><span class="line">            using (var connection = factory.CreateConnection())</span><br><span class="line">            &#123;</span><br><span class="line">                using (var channel = connection.CreateModel())</span><br><span class="line">                &#123;</span><br><span class="line">                    channel.QueueDeclare(queue: QueueName,</span><br><span class="line">                        durable: true,</span><br><span class="line">                        exclusive: false,</span><br><span class="line">                        autoDelete: false,</span><br><span class="line">                        arguments: null);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; [*] Waiting for message.&quot;);</span><br><span class="line"></span><br><span class="line">                    var consumer = new EventingBasicConsumer(channel);</span><br><span class="line"></span><br><span class="line">                    consumer.Received += (sender, ea) =&gt;</span><br><span class="line">                    &#123;</span><br><span class="line">                        var body = ea.Body;</span><br><span class="line">                        </span><br><span class="line">                        var message = System.Text.Encoding.UTF8.GetString(body);</span><br><span class="line">                        int x = int.Parse(message);</span><br><span class="line"></span><br><span class="line">                        Console.WriteLine(&quot; [x] Task &#123;0&#125; Receive &#123;1&#125; &#123;2&#125;&quot;, ea.BasicProperties.CorrelationId, message, DateTime.Now);</span><br><span class="line"></span><br><span class="line">                        Thread.Sleep(1000*x);</span><br><span class="line"></span><br><span class="line">                        Console.WriteLine(&quot; [x] Done! at &#123;0&#125;&quot;, DateTime.Now);</span><br><span class="line">                        channel.BasicAck(deliveryTag: ea.DeliveryTag, multiple: false);</span><br><span class="line">                    &#125;;</span><br><span class="line"></span><br><span class="line">                    channel.BasicConsume(queue: QueueName,</span><br><span class="line">                        noAck: false,</span><br><span class="line">                        consumer: consumer);</span><br><span class="line"></span><br><span class="line">                    Console.WriteLine(&quot; Press [enter] to exit.&quot;);</span><br><span class="line">                    Console.ReadLine();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>先启动两个消费者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ MDConsumer/bin/Debug/MDConsumer.exe</span><br><span class="line">$ MDConsumer/bin/Debug/MDConsumer.exe</span><br></pre></td></tr></table></figure><br>再启动一个生产者<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ MDProduct/bin/Debug/MDProduct.exe</span><br></pre></td></tr></table></figure></p><p>效果</p><img src="/2020/10/23/mq/rabbitmq-base-messagedispatch/round-robin.png" class="" title="效果1"> <p>这个地方其实,所有消息会很快传给消费者,虽然没有消息应答</p><img src="/2020/10/23/mq/rabbitmq-base-messagedispatch/round-robin2.png" class="" title="效果2"> <p>从上述的结果中，我们可以得知，在默认情况下，RabbitMQ不会顾虑消息者处理消息的能力，即使其中有的消费者闲置有的消费者高负荷。RabbitMQ会逐个发送消息到在序列中的下一个消费者(而不考虑每个任务的时长等等，且是提前一次性分配，并非一个一个分配)。平均每个消费者获得相同数量的消息，这种方式分发消息机制称为Round-Robin（轮询）。</p><h2 id="Fair-dispatch（公平分发）"><a href="#Fair-dispatch（公平分发）" class="headerlink" title="Fair dispatch（公平分发）"></a>Fair dispatch（公平分发）</h2><p>您可能已经注意到，任务分发仍然没有完全按照我们想要的那样。比如：现在有2个消费者，所有的奇数的消息都是繁忙的，而偶数则是轻松的。按照轮询的方式，奇数的任务交给了第一个消费者，所以一直在忙个不停。偶数的任务交给另一个消费者，则立即完成任务，然后闲得不行。而RabbitMQ则是不了解这些的。这是因为当消息进入队列，RabbitMQ就会分派消息。它不看消费者为应答的数目，只是盲目的将第n条消息发给第n个消费者。</p><p>公平分发，则是根据消费者的处理能力来进行分发处理的。这里主要是通过设置prefetchCount 参数来实现的。这样RabbitMQ就会使得每个Consumer在同一个时间点最多处理规定的数量级个数的Message。换句话说，在接收到该Consumer的ack前，它不会将新的Message分发给它。 比如prefetchCount=1，则在同一时间下，每个Consumer在同一个时间点最多处理1个Message，同时在收到Consumer的ack前，它不会将新的Message分发给它。</p><pre class="mermaid">graph LR;    P([Product]);    mq([Message Quene])    C1([Consumer1]);    C2([Consumer2]);    style P fill:#0ff,stroke:#333;    style mq fill:#f00,stroke:#333;    style C1 fill:#3cf,stroke:#333;    style C2 fill:#3cf,stroke:#333;    P-->mq;    mq-->|prefetch=1|C1;    mq-->|prefetch=1|C2;</pre><p>修改工作线程<br><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.BasicQos(prefetchCount: 1, prefetchSize: 0, global: false);</span><br></pre></td></tr></table></figure></p><p>注：如果所有的工作者都处于繁忙状态，你的队列有可能被填充满。你可能会观察队列的使用情况，然后增加工作者，或者使用别的什么策略。<br>还有一点需要注意，使用公平分发，必须关闭自动应答，改为手动应答。</p><p>效果</p><img src="/2020/10/23/mq/rabbitmq-base-messagedispatch/fair-dispatch.png" class="" title="效果1"> <p>消息每次只会发送一条给消费者，只有消费者处理完成后，才会分发新的消息<br><img src="/2020/10/23/mq/rabbitmq-base-messagedispatch/fair-dispatch2.png" class="" title="效果2"> </p><h2 id="RabbitMQ-基础知识"><a href="#RabbitMQ-基础知识" class="headerlink" title="RabbitMQ 基础知识"></a>RabbitMQ 基础知识</h2><ul><li><a href="/2020/10/23/mq/rabbitmq-base-use/" title="RabbitMQ 基础知识">RabbitMQ 基础知识</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-install/" title="RabbitMQ 安装">RabbitMQ 安装</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-exchange/" title="RabbitMQ 交换机">RabbitMQ 交换机</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-console/" title="RabbitMQ 控制台">RabbitMQ 控制台</a>  </li><li><a href="/2020/10/23/mq/rabbitmq-base-messagedispatch/" title="RabbitMQ 消息分发">RabbitMQ 消息分发</a>  </li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;任务分发&lt;/p&gt;
&lt;h2 id=&quot;任务分发机制&quot;&gt;&lt;a href=&quot;#任务分发机制&quot; class=&quot;headerlink&quot; title=&quot;任务分发机制&quot;&gt;&lt;/a&gt;任务分发机制&lt;/h2&gt;&lt;p&gt;使用任务队列的优点之一是可以轻易的进行一步工作。&lt;/p&gt;
&lt;p&gt;如果我们现在积压了很</summary>
      
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
  <entry>
    <title>RabbitMQ 消费者确认和发布者确认</title>
    <link href="http://blog.rcant.com/2020/10/23/mq/rabbitmq-confirms/"/>
    <id>http://blog.rcant.com/2020/10/23/mq/rabbitmq-confirms/</id>
    <published>2020-10-23T12:39:17.000Z</published>
    <updated>2023-01-06T09:39:20.442Z</updated>
    
    <content type="html"><![CDATA[<h2 id="总览"><a href="#总览" class="headerlink" title="总览"></a>总览</h2><ul><li>为什么需要确认</li><li>手动和自动确认模式</li><li>确认API[多次确认和重新排队]</li><li>连接丢失或通道关闭时自动重新排队</li><li>通道预取及其对吞吐量的影响</li><li>最常见的客户错误</li><li>发布者确认和相关发布者数据安全主题</li></ul><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>按照定义，使用消息传递代理(RabbitMQ)的系统是分布式的。由于不能保证发送的消息可以到达对方或者被其成功处理，因此发布者和消费者都需要一种机制来进行传递和处理确认。</p><p>从消费者到RabbitMQ的消息确认被称为消息传递协议的确认<br>对发布者的去人称为发布者确认。两种功能都基于相同的思想，启发于TCP.</p><p>这对于 发布者到RabbitMQ,RabbitMQ到消费者的可靠交付都是必不可少的。 他们对于数据安全至关重要。</p><h2 id="消费者确认"><a href="#消费者确认" class="headerlink" title="消费者确认"></a>消费者确认</h2><p>RabbitMQ 将消息传递给使用者的时候，需要知道何时消息被处理成功。具体逻辑取决于系统。因此这个是应用程序的决策.</p><span id="more"></span><h2 id="确认标识"><a href="#确认标识" class="headerlink" title="确认标识"></a>确认标识</h2><p>确认消息，重要的是如何识别确认的消息。</p><p>注册 消费者后（订阅），RabbitMQ使用 basic.deliver 方法推送消息。该方法带有传递标签，该标签唯一标识通道上的传递。因此交付标签按通道划分范围</p><p>交付标签是单调的正整数，并有客户端库标识，确认交付的客户端库方法将交付标签作为参数</p><p>由于传递</p><ul><li>basic.ack 用于确认</li><li>basic.nack 用于否定确认</li><li>basic.reject 用于否定确认，但与basic.nack 相比有一个限制</li></ul><p>自动确认模式：</p><p>消息视为发送后立即成功传递。这种模式需要权衡更高的吞吐量(只要消费者可以跟上),以降低交付和消费者处理的安全性。此模式通常称为“一劳永逸”。和手动确认模式不同，如果在成功传递前关闭了TCP连接或者通道，则服务器发送的消息将丢失。因此，自动消息确认应该被认为是不安全的，并且不适合所有有负载的工作。</p><h3 id="一次确认多个"><a href="#一次确认多个" class="headerlink" title="一次确认多个"></a>一次确认多个</h3><p>处理网络流量考虑</p>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;总览&quot;&gt;&lt;a href=&quot;#总览&quot; class=&quot;headerlink&quot; title=&quot;总览&quot;&gt;&lt;/a&gt;总览&lt;/h2&gt;&lt;ul&gt;
&lt;li&gt;为什么需要确认&lt;/li&gt;
&lt;li&gt;手动和自动确认模式&lt;/li&gt;
&lt;li&gt;确认API[多次确认和重新排队]&lt;/li&gt;
&lt;li&gt;连接丢失或通道关闭时自动重新排队&lt;/li&gt;
&lt;li&gt;通道预取及其对吞吐量的影响&lt;/li&gt;
&lt;li&gt;最常见的客户错误&lt;/li&gt;
&lt;li&gt;发布者确认和相关发布者数据安全主题&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id=&quot;基础&quot;&gt;&lt;a href=&quot;#基础&quot; class=&quot;headerlink&quot; title=&quot;基础&quot;&gt;&lt;/a&gt;基础&lt;/h2&gt;&lt;p&gt;按照定义，使用消息传递代理(RabbitMQ)的系统是分布式的。由于不能保证发送的消息可以到达对方或者被其成功处理，因此发布者和消费者都需要一种机制来进行传递和处理确认。&lt;/p&gt;
&lt;p&gt;从消费者到RabbitMQ的消息确认被称为消息传递协议的确认&lt;br&gt;对发布者的去人称为发布者确认。两种功能都基于相同的思想，启发于TCP.&lt;/p&gt;
&lt;p&gt;这对于 发布者到RabbitMQ,RabbitMQ到消费者的可靠交付都是必不可少的。 他们对于数据安全至关重要。&lt;/p&gt;
&lt;h2 id=&quot;消费者确认&quot;&gt;&lt;a href=&quot;#消费者确认&quot; class=&quot;headerlink&quot; title=&quot;消费者确认&quot;&gt;&lt;/a&gt;消费者确认&lt;/h2&gt;&lt;p&gt;RabbitMQ 将消息传递给使用者的时候，需要知道何时消息被处理成功。具体逻辑取决于系统。因此这个是应用程序的决策.&lt;/p&gt;</summary>
    
    
    
    <category term="MQ" scheme="http://blog.rcant.com/categories/MQ/"/>
    
    
    <category term="rabbitmq" scheme="http://blog.rcant.com/tags/rabbitmq/"/>
    
  </entry>
  
</feed>
