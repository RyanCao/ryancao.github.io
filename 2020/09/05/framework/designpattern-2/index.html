<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.4.2">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">
  <link rel="amphtml" href="./amp/">
  <meta name="baidu-site-verification" content="code-mUG0UNAPhR">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"blog.rcant.com","root":"/","scheme":"Muse","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":true,"show_result":true,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="引子设计模式的六大原则 结构型设计模式结构性设计模式描述 如何将类或者对象按某种布局组成更大的结构。 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或者聚合组合对象。 由于组合关系或聚合关系比较继承关系耦合度低，满足“合成复合原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下7种：  代理模式(Proxy): 为某对象提供一种代理以控制">
<meta property="og:type" content="article">
<meta property="og:title" content="23种设计模式——结构型设计模式">
<meta property="og:url" content="http://blog.rcant.com/2020/09/05/framework/designpattern-2/index.html">
<meta property="og:site_name" content="Chester.Cao Blog">
<meta property="og:description" content="引子设计模式的六大原则 结构型设计模式结构性设计模式描述 如何将类或者对象按某种布局组成更大的结构。 它分为类结构型模式和对象结构型模式，前者采用继承机制来组织接口和类，后者采用组合或者聚合组合对象。 由于组合关系或聚合关系比较继承关系耦合度低，满足“合成复合原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。 结构型模式分为以下7种：  代理模式(Proxy): 为某对象提供一种代理以控制">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2020-09-05T03:39:17.000Z">
<meta property="article:modified_time" content="2023-01-06T09:34:06.617Z">
<meta property="article:author" content="Chester.C">
<meta property="article:tag" content="架构">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://blog.rcant.com/2020/09/05/framework/designpattern-2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>23种设计模式——结构型设计模式 | Chester.Cao Blog</title>
  


  <script>
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?974592ac4c5733a52af2b871678a5334";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

<link rel="alternate" href="/atom.xml" title="Chester.Cao Blog" type="application/atom+xml">
</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Chester.Cao Blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
      <p class="site-subtitle" itemprop="description">Devlopper in C#</p>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-fw fa-home"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-fw fa-tags"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-fw fa-th"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-fw fa-archive"></i>归档</a>

  </li>
        <li class="menu-item menu-item-topics">

    <a href="/topics/" rel="section"><i class="fa fa-fw fa-pencil"></i>主题</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://blog.rcant.com/2020/09/05/framework/designpattern-2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Chester.C">
      <meta itemprop="description" content="">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Chester.Cao Blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          23种设计模式——结构型设计模式
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-09-05 11:39:17" itemprop="dateCreated datePublished" datetime="2020-09-05T11:39:17+08:00">2020-09-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-01-06 17:34:06" itemprop="dateModified" datetime="2023-01-06T17:34:06+08:00">2023-01-06</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">架构</span></a>
                </span>
            </span>

          
            <span id="/2020/09/05/framework/designpattern-2/" class="post-meta-item leancloud_visitors" data-flag-title="23种设计模式——结构型设计模式" title="阅读次数">
              <span class="post-meta-item-icon">
                <i class="fa fa-eye"></i>
              </span>
              <span class="post-meta-item-text">阅读次数：</span>
              <span class="leancloud-visitors-count"></span>
            </span>
  
  <span class="post-meta-item">
    
      <span class="post-meta-item-icon">
        <i class="fa fa-comment-o"></i>
      </span>
      <span class="post-meta-item-text">Valine：</span>
    
    <a title="valine" href="/2020/09/05/framework/designpattern-2/#valine-comments" itemprop="discussionUrl">
      <span class="post-comments-count valine-comment-count" data-xid="/2020/09/05/framework/designpattern-2/" itemprop="commentCount"></span>
    </a>
  </span>
  
  

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="引子"><a href="#引子" class="headerlink" title="引子"></a>引子</h2><p>设计模式的六大原则</p>
<h2 id="结构型设计模式"><a href="#结构型设计模式" class="headerlink" title="结构型设计模式"></a>结构型设计模式</h2><p>结构性设计模式描述 如何将类或者对象按某种布局组成更大的结构。</p>
<p>它分为类结构型模式和对象结构型模式，<br>前者采用继承机制来组织接口和类，<br>后者采用组合或者聚合组合对象。</p>
<p>由于组合关系或聚合关系比较继承关系耦合度低，满足“合成复合原则”，所以对象结构型模式比类结构型模式具有更大的灵活性。</p>
<p>结构型模式分为以下7种：</p>
<ol>
<li><p>代理模式(Proxy): 为某对象提供一种代理以控制对象的访问。即客户端通过代理简介的访问该对象，从而限制、增强或修改该对象的一些特征。</p>
</li>
<li><p>适配器模式(Adapter): 将一个类的接口转换成希望的另一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</p>
</li>
<li><p>桥接模式(Bridge): 将抽象和实现分离，使得他们可以独立变化。是用组合关系代替继承关系来实现的，从而降低了抽象和实现这两个可变维度的耦合度。</p>
</li>
<li><p>装饰模式(Decorator)：动态的给对象正将一些职责，即增加其额外的功能。</p>
</li>
<li><p>外观模式（Facade）：为多个复杂的子系统提供一个一致的接口，使得这些子系统更加容易被访问。</p>
</li>
<li><p>享元模式（Flyweight）： 使用共享技术来有效的支持大量细粒度对象的复用。</p>
</li>
<li><p>组合模式（Composite）：将对象组合成树状层次结构，使用户对单个对象和组合对象具有一致的访问性。</p>
<span id="more"></span>
<h3 id="代理模式-Proxy"><a href="#代理模式-Proxy" class="headerlink" title="代理模式(Proxy)"></a>代理模式(Proxy)</h3></li>
</ol>
<p>有些情况下，一个客户不能或者不想直接访问目标对象，这是需要找一个中介帮忙完成某项任务，这个中介就是代理对象。</p>
<p>软件设计中使用代理模式的例子很多，如：因为安全需要屏蔽客户端直接访问真实对象，如单位内部的数据库等。</p>
<h4 id="代理模式的定义与特点"><a href="#代理模式的定义与特点" class="headerlink" title="代理模式的定义与特点"></a>代理模式的定义与特点</h4><p>定义：由于某些原因需要给对象提供一个代理以控制该对象的访问。这时，访问对象不合适或者不能直接引用目标对象，代理对象作为访问对象和目标对象之间的中介。</p>
<p>代理模式的主要优点：</p>
<ul>
<li>代理模式在客户端与目标对象之间起到一个中介作用和保护目标对象的作用；</li>
<li>代理模式可以扩展目标对象的功能；</li>
<li>代理模式将客户端与目标对象分离，在一定程度上降低了系统的耦合度。</li>
</ul>
<p>主要缺点是：</p>
<ul>
<li>客户端和目标对象之间添加代理，会造成请求处理速度变慢；</li>
<li>增加了系统的复杂度。</li>
</ul>
<h4 id="代理模式的结构和实现"><a href="#代理模式的结构和实现" class="headerlink" title="代理模式的结构和实现"></a>代理模式的结构和实现</h4><p>结构比较简单，只要通过定义一个集成抽象主题的代理来包含真实主题，从而实现对真实主题的访问。</p>
<h5 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h5><p>主要角色</p>
<ul>
<li>抽象主题：通过接口或者抽象类声明真实主题或者代理对象实现的业务方法。</li>
<li>真实主题：实现抽象主题中的具体业务，是代理对象所代表的的真实对象，是最终要引用的对象。</li>
<li>代理类：提供与真实主题相同的接口，其内部含有对真实主题的引用，他可以访问控制或者扩展真实主题的功能</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">//抽象主题</span><br><span class="line">interface ISubject&#123;</span><br><span class="line">    void Request();</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 真实主题</span><br><span class="line">class RealSubject implements ISubject &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题方法...&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">// 代理</span><br><span class="line">class SubjectProxy implements ISubject &#123;</span><br><span class="line">    private ISubject realSubject;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        if (realSubject == null) &#123;</span><br><span class="line">            realSubject = new RealSubject();</span><br><span class="line">        &#125;</span><br><span class="line">        preRequest();</span><br><span class="line">        realSubject.request();</span><br><span class="line">        postRequest();</span><br><span class="line">    &#125;</span><br><span class="line">    public void preRequest() &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之前的预处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">    public void postRequest() &#123;</span><br><span class="line">        System.out.println(&quot;访问真实主题之后的后续处理。&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">public class ProxyTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        SubjectProxy proxy = new SubjectProxy();</span><br><span class="line">        proxy.Request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<h4 id="代理模式的应用场景"><a href="#代理模式的应用场景" class="headerlink" title="代理模式的应用场景"></a>代理模式的应用场景</h4><p>前面分析了代理模式的结构与特点，现在分析以下的应用 场景 。</p>
<ul>
<li><p>远程代理，这种方法通常是为了隐藏目标对象目标存在于不同地址空间的事实，方便客户端访问。例如，用户申请某些网盘空间时，会在用户的文件系统中建立一个虚拟的硬盘，用户访问虚拟硬盘时实际访问的是网盘空间。</p>
</li>
<li><p>虚拟代理，这种方式通常用于要创建的目标对象开销很大。例如，下载一个很大的图片需要很长时间，因某种计算比较复杂而短时间无法完成，这时可以先用小比例的虚拟代理替换真实的对象，消除用户对服务器慢的感觉。</p>
</li>
<li><p>安全代理，这种方式通常用于控制不同种类客户对真实对象的访问权限。</p>
</li>
<li><p>智能指引，主要用于调用目标对象时，代理附加一些额外的处理功能。例如，增加计算真实对象的引用次数的功能，这样当该对象没有被引用时，就可以自动释放它。</p>
</li>
<li><p>延迟加载，指为了提高系统的性能，延迟对目标的加载。例如，Hibernate 中就存在属性的延迟加载和关联表的延时加载。</p>
</li>
</ul>
<h4 id="代理模式的扩展"><a href="#代理模式的扩展" class="headerlink" title="代理模式的扩展"></a>代理模式的扩展</h4><p> 在前面介绍的代理模式中，代理类中包含了对真实主题引用，这种方式存在两个缺点。</p>
<p>1）真实主题与代理主题一一对应，增加真实主题也要增加代理。</p>
<p>2）设计代理以前真实主题必须事先存在，不太灵活。采用动态代理模式可以解决以上问题，如 SpringAOP，其结构图如图3-2所示。</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p> 在现实生活中，经常出现两个对象因接口不兼容而不能再一起工作的实例，这时需要第三者进行适配。例如，讲中文的人同讲英文的人对话时需要一个翻译，用直流电的笔记本电脑接交流电源时需要一个电源适配器。</p>
<p>在软件设计中也可能出现：需要开发的具有某种业务功能的组件在现有的组件库中已经存在，但它们与当前系统的接口规范不兼容，如果重写开发这些组件成本又很高，这时用是适配器模式能很好地解决这些问题。</p>
<h4 id="模式的定义与特点"><a href="#模式的定义与特点" class="headerlink" title="模式的定义与特点"></a>模式的定义与特点</h4><p>适配器模式的定义如下：将一个类的接口转换成客户希望的另一个接口，使得原本由于接口不兼容而不能一起功能的那些类能一起工作。适配器模式分为类结构型模式和对象结构型模式两种，前者之间的耦合度比后者高，其要求程序员了解现有组件库中的相关的内部结构，所以应对相对较少些。</p>
<p>该模式的主要优点如下：</p>
<ul>
<li><p>客户端通过适配器可以透明地调用目标接口。</p>
</li>
<li><p>复用了现存的类，程序员不需要修改原有代码而重用现有的适配者类。</p>
</li>
<li><p>将目标和适配这类解耦，解决了目标类和适配类接口不一致问题。</p>
</li>
</ul>
<p>其缺点是：</p>
<p>对类适配器来说，更换适配器的实现过程比较复杂。</p>
<h4 id="模式的结构与实现"><a href="#模式的结构与实现" class="headerlink" title="模式的结构与实现"></a>模式的结构与实现</h4><p>含有以下角色</p>
<ol>
<li>目标接口：当前系统业务期望的接口</li>
<li>适配类：现存组件库中的组件接口</li>
<li>适配器类：是一个适配器，通过继承或者引用适配者的对象，把适配类转换成目标接口</li>
</ol>
<p>实现：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 目标接口</span><br><span class="line">interface Target &#123;</span><br><span class="line">    public void request();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>类适配器模式的代码如下：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 适配者接口</span><br><span class="line">class Adaptee &#123;</span><br><span class="line">    public void specificRequest() &#123;</span><br><span class="line">        System.out.println(&quot;适配者中的业务代码被调用！&quot;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 类适配器类</span><br><span class="line">class ClassAdapter extends Adaptee implements Target &#123;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">//客户端代码</span><br><span class="line">public class ClassAdapterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;类适配器模式测试：&quot;);</span><br><span class="line">        Target target = new ClassAdapter();</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p> 对象适配器模式的代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> // 对象适配器类</span><br><span class="line">class ObjectAdapter implements Target &#123;</span><br><span class="line">    private Adaptee adaptee;</span><br><span class="line">    public ObjectAdapter(Adaptee adaptee) &#123;</span><br><span class="line">        this.adaptee = adaptee;</span><br><span class="line">    &#125;</span><br><span class="line">    public void request() &#123;</span><br><span class="line">        adaptee.specificRequest();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">// 客户端代码</span><br><span class="line">public class ObjectAdapterTest &#123;</span><br><span class="line">    public static void main(String[] args) &#123;</span><br><span class="line">        System.out.println(&quot;对象适配器模式测试：&quot;);</span><br><span class="line">        Adaptee adaptee = new Adaptee();</span><br><span class="line">        Target target = new ObjectAdapter(adaptee);</span><br><span class="line">        target.request();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>说明：对象适配器模式中的“目标接口”和“适配者类”的代码同类适配器模式一样，只要修改适配器类和客户端的代码即可。</p>
<h3 id="桥接模式（Bridge）"><a href="#桥接模式（Bridge）" class="headerlink" title="桥接模式（Bridge）"></a>桥接模式（Bridge）</h3><p>在现实生活中，某些具有两个或者多个维度的变化量，如图像可按形状分，也可按颜色分。<br>如果设计类似Ps这样的软件，如何去画不同形状和不同颜色的图像呢？如果用继承方式，m种形状和n种颜色的图形就有m*n种，不但对应的子类很多，而且扩展困难.</p>
<p>当然这样的例子还有很多，如不同颜色和字体的文字，不同品牌和功率的汽车，不同性别和职业的人。如果使用桥接模式就能很好的解决这些问题。</p>
<h4 id="桥接模式的定义和特点"><a href="#桥接模式的定义和特点" class="headerlink" title="桥接模式的定义和特点"></a>桥接模式的定义和特点</h4><p>定义： 将抽象和实现分离，使得它们可以独立的变化。它是用组合关系代替继承关系来实现，从而降低了抽象和实现这两个可变维度的耦合度。</p>
<p>桥接模式的优点：</p>
<ul>
<li>由于抽象和实现分离，所以扩展能力强</li>
<li>其 实现细节对客户透明</li>
</ul>
<p>缺点：</p>
<p>由于聚合关系建立在抽象层，要求开发者针对抽象化进行设计与编程，增加了系统的理解与设计难度。</p>
<h4 id="桥接模式的结构与实现"><a href="#桥接模式的结构与实现" class="headerlink" title="桥接模式的结构与实现"></a>桥接模式的结构与实现</h4><p>可以将抽象化部分与实现化部分分开，取消二者的继承关系；改用组合关系。</p>
<p>桥接模式包含以下主要角色：</p>
<p>1）抽象化角色：定义抽象类，并包含一个对实现化对象的引用。</p>
<p>2）扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法。</p>
<p>3）实现化角色：定义是实现化角色的接口，供扩展抽象化角色调用。</p>
<p>4）具体实现化角色：给出实现化角色接口的具体实现。</p>
<h4 id="桥接模式的应用场景"><a href="#桥接模式的应用场景" class="headerlink" title="桥接模式的应用场景"></a>桥接模式的应用场景</h4><p>桥接模式通常适用于以下场景：</p>
<ul>
<li>当一个类存在两个独立变化的维度，其这两个维度都需要进行扩展时。</li>
<li>当一个系统不希望使用继承或因为多层次继承导致系统类的个数急剧增加时。</li>
<li>当一个系统需要在结构的抽象画角色和具体化角色之间增加更多的灵活性时。</li>
</ul>
<h4 id="桥接模式的扩展"><a href="#桥接模式的扩展" class="headerlink" title="桥接模式的扩展"></a>桥接模式的扩展</h4><h3 id="装饰模式"><a href="#装饰模式" class="headerlink" title="装饰模式"></a>装饰模式</h3><p>现实生活中，常常需要对现有产品增加新的功能或者美化其外观，如房子装修，相片加相框等。软件开发过程中，有时想用一些现存的组件。这些组件可能只是完成了一些核心功能。但在不改变其结构的情况下，可以动态地扩展其功能。这些都可以采用装饰模式来实现。</p>
<h4 id="装饰模式的定义和特点"><a href="#装饰模式的定义和特点" class="headerlink" title="装饰模式的定义和特点"></a>装饰模式的定义和特点</h4><p>定义： 指在不改变现有对象结构的情况下，动态地给该对象增加一些职责的模式，它属于对象结构型模式。</p>
<p>主要优点：</p>
<ul>
<li>采用装饰模式扩展比采用继承扩展更加灵活。</li>
<li>可以设计出多个不同的具体装饰类，创造出多个不同行为的组合。</li>
</ul>
<p>模式的结构：</p>
<p>1）抽象构件角色：定义一个抽象接口以规范准备接收附加责任的对象。</p>
<p>2）具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责。</p>
<p>3）抽象装饰角色：继承抽象构件，并包含具体构件的实例，可以通过其子类扩展具体构件的功能。</p>
<p>4）具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附加的责任。</p>
<h4 id="装饰模式的应用场景"><a href="#装饰模式的应用场景" class="headerlink" title="装饰模式的应用场景"></a>装饰模式的应用场景</h4><p>前面讲解了关于装饰模式的结构与特点，下面介绍其适用的应用场景，装饰模式通常在以下几种情况使用。</p>
<ul>
<li>当需要给一个现有类添加附加职责，而又不能采用生成子类的方法进行扩充时。例如，该类被隐藏或者该类是终极类或者采用继承方式会产生大量的子类。</li>
<li>当需要通过对现有的一组基本功能进行排列组合而产生非常多的功能时，采用继承关系很难实现，而采用装饰模式却很好实现。</li>
<li>当对象的功能要求可以动态地添加，也可以再动态地撤销时。</li>
</ul>
<h4 id="装饰模式的变种"><a href="#装饰模式的变种" class="headerlink" title="装饰模式的变种"></a>装饰模式的变种</h4><h3 id="外观模式"><a href="#外观模式" class="headerlink" title="外观模式"></a>外观模式</h3><p>现实生活中，常常存在办事较复杂的例子，如办房产证或者注册一家公司，有时候需要同多个部门联系，这时要有一个综合部门能解决一切手续问题就好了。</p>
<p>软件设计也是这样，当一个系统的功能越来越强，子系统会越来越多，客户对系统的访问也会越来越复杂。这是如果系统内部发生改变，客户端也要跟着改变，这违背了“开闭原则”，也违背了“迪米特原则”，所以有必要为多个子系统提供一个统一的接口，从而降低系统的耦合度，这就是外观模式的目标。</p>
<p>可以简单概括</p>
<p>如果一项业务需要和多个子系统交互，那么使用外观模式将多个子系统的调用放在这项业务内部。<br>外部需要使用这项业务的地方，只需要和外观模式进行访问。</p>
<h4 id="外观模式的定义与特点"><a href="#外观模式的定义与特点" class="headerlink" title="外观模式的定义与特点"></a>外观模式的定义与特点</h4><p>外观模式的定义：是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易的被访问的模式。该模式对外有一个统一的接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p>
<p>外观模式是“迪米特法则”的典型应用</p>
<p>优点</p>
<ol>
<li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类</li>
<li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得系统使用起来更加容易。</li>
<li>降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程，因为编译一个子系统不会影响其他的子系统，也不会影响外观对象。</li>
</ol>
<p>缺点：</p>
<ol>
<li>不能很好的限制客户使用子系统类</li>
<li>增加新的子系统可能需要修改外观类或者客户端的源代码，违背了“开闭原则”。</li>
</ol>
<h4 id="外观模式的结构与实现"><a href="#外观模式的结构与实现" class="headerlink" title="外观模式的结构与实现"></a>外观模式的结构与实现</h4><p>主要 定义了一个高层接口。它包含了对各个子系统的引用，客户端可以通过它访问各个子系统的功能。</p>
<p>模式的结构：</p>
<p>1）外观（Facade）角色：为多个子系统对外提供一个共同的接口。</p>
<p>2）子系统（Sub System）角色：实现系统的部分功能，客户可以通过外观角色访问它。</p>
<p>3）客户（Client）角色：通过一个外观角色访问各个子系统的功能。</p>
<h4 id="外观模式的场景应用"><a href="#外观模式的场景应用" class="headerlink" title="外观模式的场景应用"></a>外观模式的场景应用</h4><p>通常在以下情况下可以考虑使用外观模式。</p>
<p>1）对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</p>
<p>2）当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</p>
<p>3）当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</p>
<h3 id="享元模式"><a href="#享元模式" class="headerlink" title="享元模式"></a>享元模式</h3><p>在面向对象程序设计过程中，有时会面临要创建大量相同或相似对象实例的问题。创建那么多的对象将会耗费很多的系统资源，它是系统性能提高的一个瓶颈。例如，围棋和五子棋中的黑白棋子，图像中的坐标点或颜色，局域网中的路由器、交换机和集线器，教室里的桌子和凳子等。这些对象有很多相似的地方，如果能把它们相同的部分提取出来共享，则能节省大量的系统资源，这就是享元模式的产生背景。</p>
<h4 id="享元模式的定义与特点"><a href="#享元模式的定义与特点" class="headerlink" title="享元模式的定义与特点"></a>享元模式的定义与特点</h4><p>享元模式的定义：运用共享技术来有効地支持大量细粒度对象的复用。它通过共享已经存在的又橡来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p>
<p>享元模式的主要优点是：相同对象只要保存一份，这降低了系统中对象的数量，从而降低了系统中细粒度对象给内存带来的压力。</p>
<p>其主要缺点是：</p>
<p>1）为了使对象可以共享，需要将一些不能共享的状态外部化，这将增加程序的复杂性。</p>
<p>2）读取享元模式的外部状态会使得运行时间稍微变长。</p>
<h4 id="享元模式的结构与实现"><a href="#享元模式的结构与实现" class="headerlink" title="享元模式的结构与实现"></a>享元模式的结构与实现</h4><p>享元模式中存在以下两种状态：</p>
<p>1）内部状态，即不会随着环境的改变而改变的可共享部分；</p>
<p>2）外部状态，指随环境改变而改变的不可以共享的部分。享元模式的实现要领就是区分应用中的这两种状态，并将外部状态外部化。下面来分析其基本结构和实现方法。</p>
<p>（1）模式的结构<br>享元模式的主要角色有如下：</p>
<p>1）抽象享元（Flyweight）角色：是所有的具体享元类的基类，为具体享元规范需要实现的公共接口，非享元的外部状态以参数的形式通过方法传入。</p>
<p>2）具体享元（Concrete Flyweight）角色：实现抽象享元角色中所规定的接口。</p>
<p>3）非享元（Unsharable Flyweight）角色：是不可以共享的外部状态，它以参数的形式注入具体享元的相关方法中。</p>
<p>4）享元工厂（Flyweight Factory）角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象。</p>
<h4 id="享元模式的应用场景"><a href="#享元模式的应用场景" class="headerlink" title="享元模式的应用场景"></a>享元模式的应用场景</h4><p>前面分析了享元模式的结构与特点，下面分析它适用的应用场景。享元模式是通过减少内存中对象的数量来节省内存空间的，所以以下几种情形适合采用享元模式。</p>
<p>1）系统中存在大量相同或相似的对象，这些对象耗费大量的内存资源。</p>
<p>2）大部分的对象可以按照内部状态进行分组，且可将不同部分外部化，这样每一个组只需保存一个内部状态。</p>
<p>3）由于享元模式需要额外维护一个保存享元的数据结构，所以应当在有足够多的享元实例时才值得使用享元模式。</p>
<h3 id="组合模式"><a href="#组合模式" class="headerlink" title="组合模式"></a>组合模式</h3><p>在现实生活中，存在很多“部分-整体”的关系，例如，大学中的部门与学院、总公司中的部门与分公司、学习用品中的书与书包、生活用品中的衣月艮与衣柜以及厨房中的锅碗瓢盆等。在软件开发中也是这样，例如，文件系统中的文件与文件夹、窗体程序中的简单控件与容器控件等。对这些简单对象与复合对象的处理，如果用组合模式来实现会很方便。</p>
<h4 id="组合模式的定义与特点"><a href="#组合模式的定义与特点" class="headerlink" title="组合模式的定义与特点"></a>组合模式的定义与特点</h4><p>定义： 有时又叫部分-整体模式，他说一种将对象组合成树状的层次结构的模式，用来表示“部分-整体”的关系，使用户对单个对象和组合对象具有一致的访问性。</p>
<p>优点：</p>
<ol>
<li>组合模式使得客户端代码可以一致地处理单个对象和组合对象，无须关心自己处理的是单个对象，还是组合对象，简化了客户端代码</li>
<li>更容易在组合体内加入新的对象，客户端不会因为新的对象而更改源代码，满足“开闭原则”</li>
</ol>
<p>缺点：</p>
<ol>
<li>设计较复杂，需要花更多时间理解类之间的层次关系；</li>
<li>不容易限制容器中的构件</li>
<li>不容易用继承的方法来增加构件的新功能。</li>
</ol>
<h4 id="组合模式的结构与实现"><a href="#组合模式的结构与实现" class="headerlink" title="组合模式的结构与实现"></a>组合模式的结构与实现</h4><ol>
<li>组合模式的结构</li>
</ol>
<p>包含以下主要角色：<br>1) 抽象构件角色：它主要是 作为叶子节点和树枝节点声明的公共接口，并实现它们的默认行为。在透明式的组合模式中抽象构件还声明访问和管理子类的接口；在安全式的组合模式中不声明访问和管理子类的接口，管理工作由树枝结构完成。<br>2) 树叶构件角色：是组合中的叶子节点对象，它没有子节点，用于实现抽象构件角色中的声明的公共接口。<br>3) 树枝节点角色：是组合中的树枝节点对象，他有子节点。它实现了抽象构件角色中声明的接口，主要作用是存储和管理子构件，通常有Add,Remove,GetChild等方法。</p>
<p>组合模式分为透明式和安全式</p>
<ul>
<li><p>透明式，该方式中，由于抽象构件声明了所有子类中的全部方法，所以客户端无需区别树叶对象和树枝对象，对客户端来说是透明的。但缺点是：树叶构件没有Add，Remove，GetChild方法，却要实现它们（异常或者空实现），这样会带来一些安全性问题。</p>
</li>
<li><p>安全式，该方式中，将管理构件的方法转移到树枝构件中，抽象构件和树叶构件没有对子对象的管理方法，这样就避免了上一种方式上的安全问题，但是由于树叶和分支有不同的接口，客户端在调用的时候需要知道树叶对象和树枝对象的存在，所以失去了透明性。</p>
</li>
</ul>
<h4 id="组合模式的应用场景"><a href="#组合模式的应用场景" class="headerlink" title="组合模式的应用场景"></a>组合模式的应用场景</h4><p>前面分析了组合模式的结构与特点，下面分析它适用的以下应用场景。</p>
<p>1）在需要表示一个对象整体与部分的层次结构的场合。</p>
<p>2）要求对用户隐藏组合对象与单个对象的不同，用户可以用统一的接口使用组合结构中的所有对象的场合。</p>
<p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/steffen/p/11546001.html">23种设计模式——结构型设计模式（7种）</a></p>

    </div>

    
    
    
        

  <div class="followme">
    <p>欢迎关注我的其它发布渠道</p>

    <div class="social-list">

        <div class="social-item">
          <a target="_blank" class="social-link" href="/atom.xml">
            <span class="icon">
              <i class="fa fa-rss"></i>
            </span>

            <span class="label">RSS</span>
          </a>
        </div>
    </div>
  </div>


      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E6%9E%B6%E6%9E%84/" rel="tag"># 架构</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2020/09/05/framework/designpattern-mediator/" rel="prev" title="中介者模式（Mediator）">
      <i class="fa fa-chevron-left"></i> 中介者模式（Mediator）
    </a></div>
      <div class="post-nav-item">
    <a href="/2020/09/05/csharp/csharp-async/" rel="next" title="CSharp 异步处理的几种形式">
      CSharp 异步处理的几种形式 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          
    <div class="comments" id="valine-comments"></div>

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E5%AD%90"><span class="nav-number">1.</span> <span class="nav-text">引子</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%BB%93%E6%9E%84%E5%9E%8B%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F"><span class="nav-number">2.</span> <span class="nav-text">结构型设计模式</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F-Proxy"><span class="nav-number">2.1.</span> <span class="nav-text">代理模式(Proxy)</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">2.1.1.</span> <span class="nav-text">代理模式的定义与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E5%92%8C%E5%AE%9E%E7%8E%B0"><span class="nav-number">2.1.2.</span> <span class="nav-text">代理模式的结构和实现</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E7%BB%93%E6%9E%84"><span class="nav-number">2.1.2.1.</span> <span class="nav-text">结构</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">2.1.3.</span> <span class="nav-text">代理模式的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">2.1.4.</span> <span class="nav-text">代理模式的扩展</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%82%E8%80%83"><span class="nav-number">3.</span> <span class="nav-text">参考</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.1.</span> <span class="nav-text">适配器模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">3.1.1.</span> <span class="nav-text">模式的定义与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.1.2.</span> <span class="nav-text">模式的结构与实现</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%EF%BC%88Bridge%EF%BC%89"><span class="nav-number">3.2.</span> <span class="nav-text">桥接模式（Bridge）</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">3.2.1.</span> <span class="nav-text">桥接模式的定义和特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.2.2.</span> <span class="nav-text">桥接模式的结构与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.2.3.</span> <span class="nav-text">桥接模式的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%9A%84%E6%89%A9%E5%B1%95"><span class="nav-number">3.2.4.</span> <span class="nav-text">桥接模式的扩展</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.3.</span> <span class="nav-text">装饰模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E5%92%8C%E7%89%B9%E7%82%B9"><span class="nav-number">3.3.1.</span> <span class="nav-text">装饰模式的定义和特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.3.2.</span> <span class="nav-text">装饰模式的应用场景</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%A3%85%E9%A5%B0%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%8F%98%E7%A7%8D"><span class="nav-number">3.3.3.</span> <span class="nav-text">装饰模式的变种</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.4.</span> <span class="nav-text">外观模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">3.4.1.</span> <span class="nav-text">外观模式的定义与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.4.2.</span> <span class="nav-text">外观模式的结构与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%9C%BA%E6%99%AF%E5%BA%94%E7%94%A8"><span class="nav-number">3.4.3.</span> <span class="nav-text">外观模式的场景应用</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.5.</span> <span class="nav-text">享元模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">3.5.1.</span> <span class="nav-text">享元模式的定义与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.5.2.</span> <span class="nav-text">享元模式的结构与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.5.3.</span> <span class="nav-text">享元模式的应用场景</span></a></li></ol></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F"><span class="nav-number">3.6.</span> <span class="nav-text">组合模式</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%AE%9A%E4%B9%89%E4%B8%8E%E7%89%B9%E7%82%B9"><span class="nav-number">3.6.1.</span> <span class="nav-text">组合模式的定义与特点</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E7%BB%93%E6%9E%84%E4%B8%8E%E5%AE%9E%E7%8E%B0"><span class="nav-number">3.6.2.</span> <span class="nav-text">组合模式的结构与实现</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%E7%9A%84%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="nav-number">3.6.3.</span> <span class="nav-text">组合模式的应用场景</span></a></li></ol></li></ol></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Chester.C</p>
  <div class="site-description" itemprop="description"></div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">143</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">32</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">67</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Chester.C</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://muse.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  
  <script>
    (function(){
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      bp.src = (curProtocol === 'https') ? 'https://zz.bdstatic.com/linksubmit/push.js' : 'http://push.zhanzhang.baidu.com/push.js';
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'forest',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  


<script>
NexT.utils.loadComments(document.querySelector('#valine-comments'), () => {
  NexT.utils.getScript('//unpkg.com/valine/dist/Valine.min.js', () => {
    var GUEST = ['nick', 'mail', 'link'];
    var guest = 'nick,mail,link';
    guest = guest.split(',').filter(item => {
      return GUEST.includes(item);
    });
    new Valine({
      el         : '#valine-comments',
      verify     : false,
      notify     : false,
      appId      : 'OQBlgU8H1seTDvVrgC3Dhni0-gzGzoHsz',
      appKey     : 'wF7D3hVD9WjlV9V52bhlymHO',
      placeholder: "Just go go",
      avatar     : 'mm',
      meta       : guest,
      pageSize   : '10' || 10,
      visitor    : true,
      lang       : 'zh-cn' || 'zh-cn',
      path       : location.pathname,
      recordIP   : false,
      serverURLs : ''
    });
  }, window.Valine);
});
</script>

</body>
</html>
